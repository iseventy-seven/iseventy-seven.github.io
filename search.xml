<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dsa00</title>
    <url>/2023/04/06/dsa00/</url>
    <content><![CDATA[<h1 id="数据结构（邓俊辉）"><a href="#数据结构（邓俊辉）" class="headerlink" title="数据结构（邓俊辉）"></a>数据结构（邓俊辉）</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="01-A1-计算：工具"><a href="#01-A1-计算：工具" class="headerlink" title="01-A1 计算：工具"></a>01-A1 计算：工具</h3><blockquote>
<p>01.Intro.A1.Computation.Tools</p>
</blockquote>
<ul>
<li><p>以计算为核心</p>
<blockquote>
<p>Computer Science -&gt; Computing Science</p>
</blockquote>
<ul>
<li>以计算为研究对象<ul>
<li>探究计算规律、计算技巧</li>
</ul>
</li>
<li>以计算为研究目标<ul>
<li>实现高效计算、低耗计算</li>
</ul>
</li>
</ul>
</li>
<li><p>计算工具</p>
<ul>
<li><p>绳索计算机</p>
<img src="D:\Documents\Typora\数据结构\DS\01.绳索计算机.png" alt="01.绳索计算机" style="zoom:33%;" />
</li>
<li><p>尺规计算机</p>
<img src="D:\Documents\Typora\数据结构\DS\02.尺规计算机.png" alt="02.尺规计算机" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h3 id="01-A2-计算：算法"><a href="#01-A2-计算：算法" class="headerlink" title="01-A2 计算：算法"></a>01-A2 计算：算法</h3><blockquote>
<p>01.Intro.A2.Computation.Algorithm</p>
</blockquote>
<ul>
<li><p>概念</p>
<ul>
<li><p>**$计算 &#x3D; 信息处理$**：即借助某种工具，遵照一定规则，以明确而机械的形式进行</p>
</li>
<li><p><strong>$计算模型 &#x3D; 计算机 &#x3D; 信息处理工具$</strong></p>
</li>
<li><p><strong>算法：即特定计算模型下，解决特定问题的指令序列</strong></p>
<ul>
<li><p>输入：问题</p>
</li>
<li><p>输出：答案</p>
</li>
<li><p>正确性：算法可以解决问题</p>
</li>
<li><p>确定性：算法每一步都确定</p>
</li>
<li><p>可行性：算法每一步都可行</p>
</li>
<li><p>有穷性：算法经有穷次操作</p>
<blockquote>
<p>一个算法满足确定性与可行性，当且仅当它可以通过程序设计语言精确地描述。</p>
<p>证明有穷性和正确性，即找出算法过程的不变性与单调性（随着算法推进，问题有效规模不断递减）。</p>
<p>鲁棒性（Robustness）：算法要尽可能充分地应对各种退化（Degeneracy）情况。</p>
<p>重用性、可计算性（Computability）、难解性（Intractability）</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>$程序 \not&#x3D; 算法$</strong></p>
</li>
</ul>
</li>
<li><p>算法优劣</p>
<ul>
<li>正确：符合语法，能够编译运行</li>
<li>健壮：正常退出，辨别非法输入</li>
<li>可读：正确命名，结构化与注释</li>
<li><strong>效率：速度较快，存储空间较少</strong><ul>
<li>$Algorithm + Data Structures &#x3D; Programs$</li>
<li>$(Algorithm + Data Structures) \times Efficiency &#x3D; Computing$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-B1-计算模型：统一尺度"><a href="#01-B1-计算模型：统一尺度" class="headerlink" title="01-B1 计算模型：统一尺度"></a>01-B1 计算模型：统一尺度</h3><blockquote>
<p>01.Intro.B1.Computational_Models.Measure</p>
</blockquote>
<ul>
<li>算法分析<ul>
<li>正确性</li>
<li>时间与空间成本<ul>
<li>往往与<strong>实例</strong>的规模相关</li>
</ul>
</li>
<li>依托于理想的平台或模型</li>
</ul>
</li>
<li>定义<ul>
<li>性能测度建模：$T_A(P) &#x3D; 算法 ~ A ~ 求解问题实例 ~ P ~ 的计算成本$</li>
<li>考虑问题规模：$T_A(n) &#x3D; 用算法 ~ A ~ 求解某一问题规模为 ~ n ~ 的实例，所需的计算成本$</li>
<li><strong>考虑最坏情况</strong>：$T(n) &#x3D; \max{~ T(P) ~ \vert ~ \lvert P \rvert &#x3D; n ~}$</li>
</ul>
</li>
</ul>
<h3 id="01-B2-计算模型：图灵机"><a href="#01-B2-计算模型：图灵机" class="headerlink" title="01-B2 计算模型：图灵机"></a>01-B2 计算模型：图灵机</h3><blockquote>
<p>01.Intro.B2.Computational_Models.Turing_Machine</p>
</blockquote>
<ul>
<li>TM：Turing Machine<ul>
<li>Tape<ul>
<li>无限长的一条纸带，依次均匀地划分为单元格</li>
<li>每个单元格中标注一个字符，默认为 <code>#</code></li>
</ul>
</li>
<li>Alphabet<ul>
<li>单元格中的字符种类有限，均来自于一个字符表</li>
</ul>
</li>
<li>Head<ul>
<li>头&#x2F;读写头</li>
<li>总是对准某一单元格</li>
<li>可以读取或改写单元格中的字符</li>
<li>每经过一个节拍，可移至左侧或右侧的邻格</li>
</ul>
</li>
<li>State<ul>
<li>TM 总是处于有限状态中的一种</li>
<li>每经过一个节拍，可以按照相应规则转向另一种状态</li>
</ul>
</li>
<li>Transition Function<ul>
<li><code>q</code>：当前状态</li>
<li><code>c</code>：当前单元格中的字符</li>
<li><code>d</code>：要改写成的目标字符</li>
<li><code>L/R</code>：转向左侧&#x2F;右侧邻格</li>
<li><code>p</code>：要改变的目标状态</li>
<li>转入特定状态 <code>h</code> 时，停机</li>
</ul>
</li>
</ul>
</li>
<li>TM：Increase<ul>
<li>功能<ul>
<li>将二进制非负整数加一</li>
</ul>
</li>
<li>算法<ul>
<li>全 <code>1</code> 的后缀翻转为全 <code>0</code></li>
<li>原最低位的 <code>0</code> 或 <code>#</code> 翻转为 <code>1</code></li>
</ul>
</li>
<li>指令<ul>
<li><code>(&lt;, 1, 0, L, &lt;) // 左行, 1-&gt;0</code></li>
<li><code>(&lt;, 0, 1, R, &gt;) // 掉头, 0-&gt;1</code></li>
<li><code>(&lt;, #, 1, R, &gt;)</code></li>
<li><code>(&gt;, 0, 0, R, &gt;) // 右行</code></li>
<li><code>(&gt;, #, #, L, h) // 复位</code></li>
</ul>
</li>
</ul>
</li>
<li>以<strong>接口</strong>的形式强调<strong>规范</strong></li>
</ul>
<h3 id="01-B3-计算模型：RAM"><a href="#01-B3-计算模型：RAM" class="headerlink" title="01-B3 计算模型：RAM"></a>01-B3 计算模型：RAM</h3><blockquote>
<p>01.Intro.B3.Computational_Models.RAM</p>
</blockquote>
<ul>
<li><p>RAM：Random Access Machine</p>
<ul>
<li>无限个寄存器顺序编号</li>
<li>基本操作：每一步仅需常数时间<ul>
<li><code>R[i] &lt;- c</code>：常数赋值</li>
<li><code>R[i] &lt;- R[j]</code>：数值复制</li>
<li><code>R[i] &lt;- R[R[j]]</code>：数值复制（间接取址）</li>
<li><code>R[R[i]] &lt;- R[j]</code></li>
<li><code>R[i] &lt;- R[j] + R[k]</code>：加</li>
<li><code>R[i] &lt;- R[j] - R[k]</code>：减</li>
<li><code>IF R[i] = 0 GOTO 1</code>：条件语句，判 0</li>
<li><code>IF R[i] &gt; 0 GOTO 1</code>：条件语句，判正</li>
<li><code>GOTO 1</code>：转向</li>
<li><code>STOP</code>：终止</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>计算工具的简化与抽象</strong></p>
<ul>
<li>便于独立于具体平台，评判算法效率</li>
<li>计算模型<ul>
<li>算法运行时间 $\varpropto$ 算法需要执行的基本操作次数</li>
<li><strong>$T(n) &#x3D; 算法为求解规模为 ~ n ~ 的问题，所需执行的基本操作次数$</strong></li>
<li><strong>为度量算法性能提供了精确的尺度</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>RAM：Floor</p>
<ul>
<li><p>功能</p>
<ul>
<li>向下取整的除法<br>$$<br>\begin{equation*}<br>\begin{split}<br>    \lfloor \frac{c}{d} \rfloor<br>    &amp; &#x3D; \max{x ~ \vert ~ d \cdot x \leqslant c} \<br>    &amp; &#x3D; \max{x ~ \vert ~ d \cdot x \leqslant c}<br>    , ~ 0 \leqslant c, 0 &lt; d<br>\end{split}<br>\end{equation*}<br>$$</li>
</ul>
</li>
<li><p>算法：反复从 <code>R[0] = 1 + c</code> 中减去 <code>R[1] = d</code>，统计在下溢之前所做的减法次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R[3] &lt;- 1 // increment</span><br><span class="line">R[0] &lt;- R[0] + R[3] // c++</span><br><span class="line">R[0] &lt;- R[0] - R[1] // c -= d</span><br><span class="line">R[2] &lt;- R[2] + R[3] // x++</span><br><span class="line">IF R[0] &gt; 0 GOTO 2 // if c &gt; 0 goto 2</span><br><span class="line">R[0] &lt;- R[2] - R[3] // else x--</span><br><span class="line">STOP // return R[0] = x</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="01-C1-渐进复杂度：大-O-记号"><a href="#01-C1-渐进复杂度：大-O-记号" class="headerlink" title="01-C1 渐进复杂度：大 $O$ 记号"></a>01-C1 渐进复杂度：大 $O$ 记号</h3><blockquote>
<p>01.Intro.C1.Asymptotic_Complexity.Big_O</p>
</blockquote>
<ul>
<li><p>渐进分析：问题规模足够大后，计算成本如何增长</p>
<ul>
<li><p>大 $O$ 记号</p>
<ul>
<li>对于 $T(n) &#x3D; O(f(n))$，$\exists c &gt; 0$，当 $n &gt;&gt; 2$ 后，有 $T(n) &lt; c \cdot f(n)$<ul>
<li>常系数可忽略：$O(c \times f(n)) &#x3D; O(f(n))$</li>
<li>低次项可忽略：$O(n^a + n^b) &#x3D; O(n^a), a \geqslant b &gt; 0$</li>
<li>$O(f(n))$ 是对 $T(n)$ 的悲观估计</li>
</ul>
</li>
</ul>
</li>
<li><p>大 $\Omega$ 记号</p>
<ul>
<li>对于 $T(n) &#x3D; \Omega(f(n))$，$\exists  c &gt; 0$，当 $n &gt;&gt; 2$ 后，有 $T(n) &gt; c \cdot f(n)$<ul>
<li>$\Omega(f(n))$ 是对 $T(n)$ 的乐观估计</li>
</ul>
</li>
</ul>
</li>
<li><p>$\Theta$ 记号</p>
<ul>
<li><p>对于 $T(n) &#x3D; \Theta(f(n))$，$\exists c_1 &gt; \exists c_2 &gt; 0$，当 $n &gt;&gt; 2$ 后，有 $c_1 \cdot f(n) &gt; T(n) &gt; c_2 \cdot f(n)$</p>
<blockquote>
<p>对于规模为 $n$ 的任何输入，算法的运行时间 $T(n)$ 都与 $\Theta(f(n))$ 同阶。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-C2-渐进复杂度：多项式"><a href="#01-C2-渐进复杂度：多项式" class="headerlink" title="01-C2 渐进复杂度：多项式"></a>01-C2 渐进复杂度：多项式</h3><blockquote>
<p>01.Intro.C2.Asymptotic_Complexity.Polynomial</p>
</blockquote>
<ul>
<li><p>高效解</p>
<ul>
<li>$O(1)$：常数（constant function）<ul>
<li>效率最高</li>
</ul>
</li>
<li>$O(\log^c n)$：对数多项式（ploy-log function）<ul>
<li>忽视常底数：$\forall a, b &gt; 0, \log_a n &#x3D; \log_ab \cdot \log_b n &#x3D; \Theta(\log_b n)$</li>
<li>忽视常次数幂：$\forall c &gt; 0, \log n^c &#x3D; c \cdot \log n &#x3D; \Theta(\log n)$</li>
<li>$\exists c &gt; 0, \log n &#x3D; O(n^c)$</li>
</ul>
</li>
</ul>
</li>
<li><p>有效解</p>
<ul>
<li>$O(n^c)$：多项式（polynomial function）<ul>
<li>一般地：$a_k n^k + a_{k - 1} n^{k - 1} + \cdots + a_1 n + a_0 &#x3D; O(n^k), a_k &gt; 0$</li>
<li>所有 $O(n)$ 类函数均为线性（linear function）的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-C3-渐进复杂度：指数"><a href="#01-C3-渐进复杂度：指数" class="headerlink" title="01-C3 渐进复杂度：指数"></a>01-C3 渐进复杂度：指数</h3><blockquote>
<p>01.Intro.C3.Asymptotic_Complexity.Exponential</p>
</blockquote>
<ul>
<li>难解<ul>
<li>$O(a^n)$：指数（exponential function）<ul>
<li>$\forall c &gt; 1, n^c &#x3D; O(2^n)$</li>
<li>从 $O(n^c)$ 到 $O(2^n)$ 是<strong>有效算法</strong>到<strong>无效算法</strong>的分水岭</li>
<li>2-Subset 问题：$S$ 包含 $n$ 个正整数，$\sum S &#x3D; 2m$，$S$ 是否有子集 $T$，满足 $\sum T &#x3D; m$？<ul>
<li>2-Subset is NP-complete. (Non-deterministic Polynomial)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-C4-渐进复杂度：层级划分"><a href="#01-C4-渐进复杂度：层级划分" class="headerlink" title="01-C4 渐进复杂度：层级划分"></a>01-C4 渐进复杂度：层级划分</h3><blockquote>
<p>01.Intro.C4.Asymptotic_Complexity.Complexity_Class</p>
</blockquote>
<ul>
<li>增长速度<ul>
<li>$2^n &gt; n^3 &gt; n^2 &gt; n \log n &gt; n &gt; \sqrt{n} &gt; \log{n} &gt; 1$</li>
</ul>
</li>
</ul>
<h3 id="01-D1-复杂度分析：级数"><a href="#01-D1-复杂度分析：级数" class="headerlink" title="01-D1 复杂度分析：级数"></a>01-D1 复杂度分析：级数</h3><blockquote>
<p>01.Intro.D1.Complexity_Analysis.Series</p>
</blockquote>
<ul>
<li>算法分析<ul>
<li>主要任务<ul>
<li>正确性（不变性 $\times$ 单调性）+ 复杂度</li>
</ul>
</li>
<li>主要方法<ul>
<li>迭代：级数求和</li>
<li>递归：递归跟踪 + 递推方程</li>
<li>猜测 + 验证</li>
</ul>
</li>
</ul>
</li>
<li>级数<ul>
<li>算术级数：与<strong>末项平方</strong>同阶<ul>
<li>$T(n) &#x3D; 1 + 2 + \cdots + n &#x3D; n (n + 1) &#x2F; 2 &#x3D; O(n^2)$</li>
</ul>
</li>
<li>幂方级数：比幂次高出<strong>一阶</strong><ul>
<li>$\sum^n_{k&#x3D;0} k^d \approx \int^n_0 x^{d + 1} {\rm d} x &#x3D; \frac{1}{d + 1} x ^{d + 1} \vert^n_0 &#x3D; \frac{1}{d + 1} n^{d + 1} &#x3D; O(n^{d + 1})$</li>
<li>$T_2(n) &#x3D; 1^2 + 2^2 + 3^2 + \cdots + n^2 &#x3D; \frac{n (n + 1) (2n + 1)}{6} &#x3D; O(n^3)$</li>
<li>$T_3(n) &#x3D; 1^3 + 2^3 + 3^3 + \cdots + n^3 &#x3D; \frac{n^2 (n + 1)^2}{4} &#x3D; O(n^4)$</li>
<li>$T_4(n) &#x3D; 1^4 + 2^4 + 3^4 + \cdots + n^4 &#x3D; \frac{n (n + 1) (2n + 1) (3n^2 + 3n - 1)}{30} &#x3D; O(n^5)$</li>
</ul>
</li>
<li>几何级数（$a &gt; 1$）：与<strong>末项</strong>同阶<ul>
<li>$T_a(n) &#x3D; \sum\limits_{k &#x3D; 0}^n a^k &#x3D; a^0 + a^1 + \cdots + a^n &#x3D; \frac{a^{n + 1} - 1}{a - 1} &#x3D; O(a^n), ~ 1 &lt; a$</li>
<li>$T_2(n) &#x3D; 1 + 2 + 4 + \cdots + 2^n &#x3D; 2^{n + 1} - 1 &#x3D; O(2^{n + 1}) &#x3D; O(2^n)$</li>
</ul>
</li>
<li>收敛级数<ul>
<li>$\sum\limits_{k &#x3D; 2}^n \dfrac{1}{(k - 1) \cdot k} &#x3D; \dfrac{1}{1 \cdot 2} + \dfrac{1}{2 \cdot 3} + \dfrac{1}{3 \cdot 4} + \cdots + \dfrac{1}{(n - 1) \cdot (n)} &#x3D; 1 - \dfrac{1}{n} &#x3D; O(1)$</li>
<li>$\sum\limits_{k &#x3D; 1}{n} \dfrac{1}{k^2} &#x3D; 1 + \dfrac{1}{2^2} + \cdots + \dfrac{1}{n^2} &lt; 1 + \dfrac{1}{2^2} + \cdots &#x3D; \dfrac{\pi^2}{6} &#x3D; O(1)$</li>
<li>$\sum\limits_{k &#x3D; power} \dfrac{1}{k - 1} &#x3D; \dfrac{1}{3} + \dfrac{1}{7} + \dfrac{1}{8} + \dfrac{1}{15} + \dfrac{1}{24} + \dfrac{1}{26} + \dfrac{1}{31} + \dfrac{1}{35} + \cdots &#x3D; 1 &#x3D; O(1)$</li>
<li>$(1 - \lambda) \cdot [1 + 2 \lambda + 3 \lambda^2 + 4 \lambda^3 + \cdots] &#x3D; \dfrac{1}{1 - \lambda} &#x3D; O(1), 0 &lt; \lambda &lt; 1$，几何分布<ul>
<li>投掷硬币，正面概率为 $\lambda$，不断投掷直到第一次出现反面</li>
</ul>
</li>
</ul>
</li>
<li>调和级数<ul>
<li>$h(n) &#x3D; \sum\limits_{k &#x3D; 1}^n \dfrac{1}{k} &#x3D; 1 + \dfrac{1}{2} + \dfrac{1}{3} + \cdots + \dfrac{1}{n} &#x3D; \Theta(\log n)$</li>
</ul>
</li>
<li>对数级数<ul>
<li>$\sum\limits_{k &#x3D; 1}^n \ln k &#x3D; \log 1 + \log 2 + \log 3 + \cdots + \log n &#x3D; \log (n!) &#x3D; \Theta(n \log n)$</li>
</ul>
</li>
<li>对数 + 线性 + 指数<ul>
<li>$\sum\limits_{k &#x3D; 1}^n k \cdot \log k &#x3D; O(n^2 \log n)$</li>
<li>$\sum\limits_{k &#x3D; 1}^n k \cdot 2^k &#x3D; O(n \cdot 2^n)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-D2-复杂度分析：迭代"><a href="#01-D2-复杂度分析：迭代" class="headerlink" title="01-D2 复杂度分析：迭代"></a>01-D2 复杂度分析：迭代</h3><blockquote>
<p>01.Intro.D2.Complexity_Analysis.Iteration</p>
</blockquote>
<ul>
<li><p>循环与级数</p>
<ul>
<li><p>第一类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">Operqation</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>算术级数：$\sum^{n - 1}_{i &#x3D; 0} n &#x3D; n + n + \cdots + n &#x3D; n * n &#x3D; O(n^2)$</p>
</li>
<li><p>抽象做正方形</p>
<img src="D:\Documents\Typora\数据结构\DS\03.循环-级数1.png" alt="03.循环-级数1" style="zoom: 33%;" />

<blockquote>
<p>对于 $n + n + \cdots + n$，等价于 $n * 1 + n * 1 + \cdots + n * 1$，也就是 $n \times n$ 的元素全为 $1$ 的矩阵。这里的抽象过程，其实是将矩阵的每个元素都看成单位面积为 1 的小正方形，由此离散的点可转化为连续的图形，而求其和就是求整个拼成的大图形中，有多少个小正方形，由于小正方形面积为 1，因此大正方形的面积即为小正方形数量，即 $\sum &#x3D; \frac{S}{1} &#x3D; S$。</p>
<p>对于上述式子，最终抽象为边长为 $n$ 的正方形。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第二类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="built_in">Operation</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>算术级数：$\sum^{n - 1}_{i &#x3D; 0} i &#x3D; 0 + 1 + \cdots + (n - 1) &#x3D; \frac{n(n - 1)}{2} &#x3D; O(n^2)$</p>
</li>
<li><p>抽象做三角形</p>
<img src="D:\Documents\Typora\数据结构\DS\04.循环-级数2.png" alt="04.循环-级数2" style="zoom:33%;" />

<blockquote>
<p>同理，上述式子可抽象做底边长为 $n - 1$，高为 $n$ 的直角三角形。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第三类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j += x) &#123;</span><br><span class="line">        <span class="built_in">Operation</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>算术级数：$\sum &#x3D; \frac{n(n - 1)}{2x} &#x3D; O(n^2)$</p>
</li>
<li><p>抽象做底边更短的三角形</p>
<img src="D:\Documents\Typora\数据结构\DS\05.循环-级数3.png" alt="05.循环-级数3" style="zoom:33%;" />

<blockquote>
<p>同理，上述式子可抽象做底边长为 $\frac{n - 1}{x}$，高为 $n$ 的直角三角形。</p>
<p>这里是将原式近似看作内循环每次步长为 $\dfrac{1}{x}$，因此等效为底边长 $\dfrac{n - 1}{x}$ 的三角形。对于实际情况来说，这段代码执行次数应为 $1 \cdot x + 2 \cdot x + \cdots + \dfrac{n}{x} \cdot x + m \cdot (\dfrac{n}{x} + 1) &#x3D; x \cdot \dfrac{\dfrac{n}{x} \cdot (\dfrac{n}{x} + 1)}{2} + m \cdot (\dfrac{n}{x} + 1) &#x3D; \dfrac{n \cdot (n + x + 2m) + 2mx}{2x}$，其中 $m$ 为 $\dfrac{n}{x}$ 的余项。可以看出近似结果与真实结果都为 $O(n^2)$，它们的差值为 $\dfrac{2m + n}{2} + \dfrac{n(2m + 1)}{2x}$。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第四类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// 左移一位，等效于乘 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="built_in">Operation</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>几何级数：$1 + 2 + 4 + \cdots + 2^{\lfloor \log_2 (n - 1) \rfloor} &#x3D; \sum^{\lfloor \log_2 (n - 1) \rfloor}_{k &#x3D; 0} 2^k, (k &#x3D; \log_2 i) &#x3D; 2^{\lceil \log_2 n \rceil} - 1 &#x3D; O(n)$</p>
</li>
<li><p>抽象做缺一块单位面积正方形的长方形</p>
<img src="D:\Documents\Typora\数据结构\DS\06.循环-级数4.png" alt="06.循环-级数4" style="zoom:33%;" />

<blockquote>
<p>同理，上述式子可抽象做面积为 $2^{\lfloor \log_2 (n - 1) \rfloor}$ 的两个长方形拼成的图形挖去中间面积为 $1$ 的正方形后的图形。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第五类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j += j) &#123;</span><br><span class="line">        <span class="built_in">Operation</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>几何级数：$0 + 0 + 1 + 2 * 2 + 3 * 4 + 4 * 8 + \cdots &#x3D; 0 + \sum^n_{k &#x3D; 1} \lceil \log_2 k \rceil &#x3D; \sum_{k &#x3D; 0 \cdots \log n} (k * 2^{k - 1}) &#x3D; O(\log n * 2^{\log n}) &#x3D; O(n \log n)$</p>
</li>
<li><p>进行如下抽象</p>
<img src="D:\Documents\Typora\数据结构\DS\07.循环-级数5.png" alt="07.循环-级数5" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>取非极端元素</p>
<ul>
<li><p>问题：给定整数子集 $S$，$lvert ~ S ~ \rvert &#x3D; n \geqslant 3$，找出元素 $a \in S$，$a \neq \max(S)$ 且 $a \neq \min(S)$。</p>
</li>
<li><p>算法：从 $S$ 中任取三个元素 ${x, y, z}$，由于 $S$ 是集合，故三者必互异。确定并排除其中的最小、最大者，输出剩下的元素。</p>
<ul>
<li><p>特点：无论输入规模 $n$ 多大，该算法需要的执行时间都不变。</p>
</li>
<li><p>$T(n) &#x3D; 常数 &#x3D; O(1) &#x3D; \Omega(1) &#x3D; \Theta(1)$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>起泡排序</p>
<ul>
<li><p>问题：给定 $n$ 个整数，将它们按（非降序）序排列。</p>
</li>
<li><p>分析：有序&#x2F;无序序列中，任意&#x2F;总有一堆相邻元素顺序&#x2F;逆序（逆序紧邻对）。</p>
</li>
<li><p>算法：一次比较每一对相邻元素，如有必要，交换之。若整趟扫描都没有进行交换，则排序完成；否则，再做一趟扫描交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i<span class="number">-1</span>] &gt; A[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i - <span class="number">1</span>], A[i]);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不变性：经 $k$ 轮扫描交换后，最大的 $k$ 个元素必然就位。</p>
</li>
<li><p>单调性：经 $k$ 轮扫描交换后，问题规模缩减至 $n - k$。</p>
</li>
<li><p>正确性：经至多 $n$ 趟扫描后，算法必然终止，且能给出正确解答。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-D3-复杂度分析：封底估算"><a href="#01-D3-复杂度分析：封底估算" class="headerlink" title="01-D3 复杂度分析：封底估算"></a>01-D3 复杂度分析：封底估算</h3><blockquote>
<p>01.Intro.D3.Complexity_Analysis.Back_of_Envelope</p>
</blockquote>
<ul>
<li>Back-Of-The-Envelope Calculation 封底估算<ul>
<li>$1 天 &#x3D; 24 ~ hr \times 60 ~ min \times 60 ~ sec \approx 25 \times 4000 &#x3D; 10^5 ~ sec$</li>
<li>$1 生 \approx 1 世纪 &#x3D; 100 ~ yr \times 365 &#x3D; 3 \times 10^4 ~ day &#x3D; 3 \times 10^9 ~sec$</li>
<li>$为祖国健康工作五十年 \approx 1.6 \times 10^9 ~ sec$</li>
<li>$三生三世 \approx 300 ~ yr &#x3D; 10^{10} &#x3D; (1 ~ googel)^{\frac{1}{10}} ~ sec$</li>
<li>$宇宙大爆炸至今 &#x3D; 10^{21} &#x3D; 10 \times (10^{10})^2 ~ sec$</li>
<li>普通 PC：$1 秒 10^9 ~ flops$</li>
</ul>
</li>
</ul>
<h3 id="01-E1-迭代与递归：减而治之"><a href="#01-E1-迭代与递归：减而治之" class="headerlink" title="01-E1 迭代与递归：减而治之"></a>01-E1 迭代与递归：减而治之</h3><blockquote>
<p>01.Intro.E1.Iteration+Recursion.Decrease_and_Conquer</p>
</blockquote>
<ul>
<li><p>数组求和：迭代</p>
<ul>
<li><p>问题：计算任意 $n$ 个整数之和</p>
</li>
<li><p>算法：逐一取出每个元素，累加之</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SumI</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// O(1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// O(n)</span></span><br><span class="line">        sum += A[i]; <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>$T(n) &#x3D; 1 + n * 1 + 1 &#x3D; n + 2 &#x3D; O(n) &#x3D; \Omega (n) &#x3D; \Theta (n)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
<ul>
<li>除了输入本身所占的空间之外，所需要的另加的用于计算所必须的空间的总量。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>减而治之（Decrease-and-Conquer）</p>
<ul>
<li><p>为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡，另一规模缩减（单调性），且形式与原问题相似，分别求解子问题，由子问题的解，得到原问题的解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph</span><br><span class="line">	a(原问题)</span><br><span class="line">	b(&quot;子问题（问题规模小于原问题）&quot;)</span><br><span class="line">	c(&quot;子问题（单一问题）&quot;)</span><br><span class="line">	</span><br><span class="line">	a -- 缩减 --&gt; b</span><br><span class="line">	a -- 平凡 --&gt; c</span><br><span class="line">	b -- 治 --&gt; b</span><br><span class="line">	b -- 合 --&gt; a</span><br><span class="line">	c -- 治 --&gt; c</span><br><span class="line">	c -- 合 --&gt; a</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组求和：线性递归</p>
<ul>
<li><p>算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">1</span>) ? <span class="number">0</span> : <span class="built_in">sum</span>(A, n - <span class="number">1</span>) + A[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>递归跟踪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph</span><br><span class="line">	a(&quot;main()&quot;)</span><br><span class="line">	b(&quot;sum(A, n)&quot;)</span><br><span class="line">	c(&quot;sum(A, n - 1)&quot;)</span><br><span class="line">	d(&quot;sum(A, n - 2)&quot;)</span><br><span class="line">	e(&quot;sum(A, 2)&quot;)</span><br><span class="line">	f(&quot;sum(A, 1)&quot;)</span><br><span class="line">	g(&quot;sum(A, 0)&quot;)</span><br><span class="line">	</span><br><span class="line">	a --&gt; b --&gt; c --&gt; d</span><br><span class="line">	d -. recursive calls ..-&gt; e</span><br><span class="line">	e --&gt; f --&gt; g</span><br><span class="line">	g --&gt; f --&gt; e</span><br><span class="line">	e -.-&gt; d</span><br><span class="line">	d --&gt; c --&gt; b --&gt; a</span><br></pre></td></tr></table></figure>

<ul>
<li>$T(n) &#x3D; O(1) \times (n + 1) &#x3D; O(n)$</li>
</ul>
</li>
<li><p>递推方程</p>
<ul>
<li><p>为求解 <code>sum(A, n)</code>，需递归求解规模为 $n - 1$ 的问题 <code>sum(A, n - 1)</code>，再累加上 <code>A[n - 1]</code>，其中递归基为 <code>sum(A, 0)</code>。</p>
<blockquote>
<p><strong>注</strong>	”递归基“是递归函数的一种平凡情况，在问题规模缩减到递归基对应的问题规模时，停止递归。由于可能还会进行其它操作，不一定直接返回函数，换句话说，递归是方法，函数是方法的载体和表现形式，递归的开始与结束和函数的调用与返回没有关系。</p>
</blockquote>
<p>$$<br>T(n) &#x3D; T(n - 1) + O(1), ~ T(0) &#x3D; O(1) \\</p>
<p>\begin{equation*}<br>\begin{split}<br>    T(n) - n<br>        &amp; &#x3D; T(n - 1) - (n - 1) &#x3D; \cdots \<br>        &amp; &#x3D; T(2) - 2 \<br>        &amp; &#x3D; T(1) - 1 \<br>        &amp; &#x3D; T(0) \<br>\end{split}<br>\end{equation*} \\</p>
<p>T(n) &#x3D; O(1) + n &#x3D; O(n)<br>$$</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>例如：若 $A &#x3D; {1, 2, 3, 4, 5}$，则 $\text{sum}(1, 2, 3, 4, 5) &#x3D; \text{sum}(1, 2, 3, 4) + 5 &#x3D; \cdots$，则 $T(4) &#x3D; T(3) + O(1) &#x3D; (T(2) + O(1)) + O(1) &#x3D; \cdots &#x3D; 5O(1)$。符合公式。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>递归跟踪（Recursion Trace）</p>
<ul>
<li>每个递归实例累计所需时间（调用语句本身计入对应的子实例）即算法执行时间。</li>
<li>特点：直观形象，但仅适用于简明的递归模式。</li>
</ul>
</li>
<li><p>递推方程</p>
<ul>
<li>特点：间接抽象，更适用于复杂的递归模式。</li>
</ul>
</li>
<li><p>数组倒置</p>
<ul>
<li><p>问题：任给数组 $A[0, n)$，将其前后颠倒</p>
</li>
<li><p>算法</p>
<ul>
<li><p>递归版（$O(n)$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(A[lo], A[hi]);</span><br><span class="line">        <span class="built_in">reverse</span>(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代版（$O(n)$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    next:</span><br><span class="line">    	<span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">        	<span class="built_in">swap</span>(A[lo], A[hi]);</span><br><span class="line">        </span><br><span class="line">        	lo++;</span><br><span class="line">        	hi--;</span><br><span class="line">        </span><br><span class="line">        	<span class="keyword">goto</span> next;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(A[lo++], A[hi--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-E2-迭代与递归：分而治之"><a href="#01-E2-迭代与递归：分而治之" class="headerlink" title="01-E2 迭代与递归：分而治之"></a>01-E2 迭代与递归：分而治之</h3><blockquote>
<p>01.Intro.E2.Iteration+Recursion.Divide_and_Conquer</p>
</blockquote>
<ul>
<li><p>分而治之（Divide-and-Conquer）</p>
<ul>
<li><p>为求接一个大规模的问题，可以将其划分为若干（通常两个）子问题，规模大体相当，分别求解子问题，由子问题的解，得到原问题的解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph</span><br><span class="line">	a(原问题)</span><br><span class="line">	b(子问题)</span><br><span class="line">	c(子问题)</span><br><span class="line">	</span><br><span class="line">	a -- 分 --&gt; b &amp; c</span><br><span class="line">	b -- 治 --&gt; b</span><br><span class="line">	c -- 治 --&gt; c</span><br><span class="line">	b -- 合 --&gt; a</span><br><span class="line">	c -- 合 --&gt; a</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组求和：二分递归</p>
<ul>
<li><p>算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123; <span class="comment">// [lo, hi)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(A, lo, mi) + <span class="built_in">sum</span>(A, mi, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>递归跟踪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph</span><br><span class="line">	a(&quot;sum(0, n - 1)&quot;)</span><br><span class="line">	b(&quot;sum(0, (n - 1) / 2)&quot;)</span><br><span class="line">	c(&quot;sum((n - 1) / 2, n - 1)&quot;)</span><br><span class="line">	d(&quot;sum(0, (n - 1) / 4&quot;)</span><br><span class="line">	e(&quot;sum((n - 1) / 4, (n - 1) / 2)&quot;)</span><br><span class="line">	f(&quot;sum((n -  1) / 2), (3 * (n - 1)) / 2&quot;)</span><br><span class="line">	g(&quot;sum((3 * (n - 1)) / 2, n - 1)&quot;)</span><br><span class="line">	h(&quot;sum(0, 0)&quot;)</span><br><span class="line">	i(&quot;sum(1, 1)&quot;)</span><br><span class="line">	j(&quot;sum(2, 2)&quot;)</span><br><span class="line">	k(&quot;sum(3, 3)&quot;)</span><br><span class="line">	l(&quot;sum(n - 4, n - 4)&quot;)</span><br><span class="line">	m(&quot;sum(n - 3, n - 3)&quot;)</span><br><span class="line">	n(&quot;sum(n - 2, n - 2)&quot;)</span><br><span class="line">	o(&quot;sum(n - 1, n - 1)&quot;)</span><br><span class="line">	</span><br><span class="line">	a --&gt; b &amp; c</span><br><span class="line">    b --&gt; d &amp; e</span><br><span class="line">    c --&gt; f &amp; g</span><br><span class="line">    d -.-&gt; h &amp; i</span><br><span class="line">    e -.-&gt; j &amp; k</span><br><span class="line">    f -.-&gt; l &amp; m</span><br><span class="line">    g -.-&gt; n &amp; o</span><br></pre></td></tr></table></figure>

<ul>
<li>$T(n) &#x3D; O(1) \times (2^0 + 2^1 + 2^2 + \cdots + 2^{\log n}) &#x3D; O(1) \times (2^{1 + \log n} - 1) &#x3D; O(n)$</li>
</ul>
</li>
<li><p>递推方程</p>
<ul>
<li><p>为求解 <code>sum(A, lo, hi)</code>，需递归求解 <code>sum(A, lo, mi)</code> 和 <code>sum(A, mi, hi)</code>，进而将子问题的解累加，其中递归基为 <code>sum(A, k, k + 1)</code>。<br>$$<br>T(n) &#x3D; 2 \times T(\frac{n}{2}) + O(1), ~ T(1) &#x3D; O(1) \\</p>
<p>\begin{equation*}<br>\begin{split}<br>    T(n) + 1<br>        &amp; &#x3D; 2 \times (T(\frac{n}{2}) + 1) \<br>        &amp; &#x3D; 2^2 \times (T(\frac{n}{2^2}) + 1)h &#x3D; \cdots \<br>        &amp; &#x3D; 2^{\log n} \times (T(1) + 1) \<br>        &amp; &#x3D; 2n<br>\end{split}<br>\end{equation*} \\</p>
<p>T(n) &#x3D; 2n - O(1) &#x3D; O(n)<br>$$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>例如：若 $A &#x3D; {1, 2, 3, 4, 5}$，则 $\text{sum}(1, 2, 3, 4, 5) &#x3D; \text{sum}(1, 2, 3) + \text{sum}(4, 5) &#x3D; \cdots$，则 $T(5) &#x3D; T(3) + T(2) + O(1) &#x3D; \cdots &#x3D; 9(O(1))$。符合公式。</p>
</blockquote>
</li>
<li><p>大师定理&#x2F;主定理（Master Theorem）</p>
<ul>
<li>分治策略对应的递推式，通常（尽管不总是）形如：$T(n) &#x3D; a \cdot T(\frac{n}{b}) + O(f(n))$，即原问题被分为 $a$ 个规模均为 $\frac{n}{b}$ 的子任务，任务的划分、解的合并耗时 $f(n)$。</li>
<li>求解（比较 $n^{\log_b{a}}$ 与 $f(x)$，若他们之间有明显的大小关系，则取大的作为 $T(n)$）<ul>
<li>若 $f(x) &#x3D; O(n^{\log_b{a} - \varepsilon})$，则 $T(n) &#x3D; \Theta(n^{\log_b{a}})$</li>
<li>若 $f(n) &#x3D; \Theta(n^{\log_b{a}} \cdot \log^k n)$，则 $T(n) &#x3D; \Theta(n^{\log_b{a}} \cdot \log^{k + 1} n)$</li>
<li>若 $f(x) &#x3D; \Omega(n^{\log_b{a} + \varepsilon})$，则 $T(n) &#x3D; \Theta(f(n))$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-E3-迭代与递归：总和最大区段"><a href="#01-E3-迭代与递归：总和最大区段" class="headerlink" title="01-E3 迭代与递归：总和最大区段"></a>01-E3 迭代与递归：总和最大区段</h3><blockquote>
<p>01.Intro.E3.Iteration+Recursion.Greatest_Slice</p>
</blockquote>
<ul>
<li><p>总和最大区段</p>
<ul>
<li><p>问题：从整数序列中，找出总和最大的区段（有多个时，短者、靠后者优先）。</p>
</li>
<li><p>蛮力策略（$O(n^3)$）</p>
<ul>
<li><p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gs_BF</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> gs = A[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">// 枚举所有 O(n^2) 个区段</span></span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; k++) &#123; <span class="comment">// 对区段求和</span></span><br><span class="line">                s += A[k];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (gs &lt; s) &#123; <span class="comment">// 择优更新</span></span><br><span class="line">                gs = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>递增策略（$O(n^2)$）</p>
<ul>
<li><p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gs_IC</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> gs = A[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 枚举所有起始于 i 的区间</span></span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">// 枚举所有终止于 j 的区间</span></span><br><span class="line">            s += A[j]; <span class="comment">// 递增地求和</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (gs &lt; s) &#123; <span class="comment">// 实时更新</span></span><br><span class="line">                gs = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分治策略（$O(n \cdot \log n)$）</p>
<p>- </p>
<ul>
<li><p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gs_DC</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; <span class="number">2</span>) &#123; <span class="comment">// 递归基</span></span><br><span class="line">        <span class="keyword">return</span> A[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mi = (lo + hi) / <span class="number">2</span>; <span class="comment">// 中点切分</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> gsL = A[mi - <span class="number">1</span>], sL = <span class="number">0</span>, i = mi; <span class="comment">// 枚举</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt; i--) &#123; <span class="comment">// 所有 [i, mi) 类区段</span></span><br><span class="line">        <span class="keyword">if</span> (gsL &lt; (sL += A[i])) &#123; <span class="comment">// 更新</span></span><br><span class="line">            gsL = sL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> gsR = A[mi], sR = <span class="number">0</span>, j = mi - <span class="number">1</span>; <span class="comment">// 枚举</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (++j &lt; hi) &#123; <span class="comment">// 所有 [mi, j) 类区段</span></span><br><span class="line">        <span class="keyword">if</span> (gsR &lt; (sR += A[j])) &#123; <span class="comment">// 更新</span></span><br><span class="line">            gsR = sR; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(gsL + gsR, <span class="built_in">max</span>(<span class="built_in">gs_DC</span>(A, lo, mi), <span class="built_in">gs_DC</span>(A, mi, hi)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-F1-动态规划：记忆法"><a href="#01-F1-动态规划：记忆法" class="headerlink" title="01-F1 动态规划：记忆法"></a>01-F1 动态规划：记忆法</h3><blockquote>
<p>01.Intro.F1.Dynamic_Programming.Memoization</p>
</blockquote>
<ul>
<li><p>动态规划</p>
<ul>
<li>设计一个好的算法，就是通过递归，找出算法的本质，并给出一个初步的解之后，再将其等效的转化为迭代形式。</li>
</ul>
</li>
<li><p>$fib(n)$：递归</p>
<ul>
<li><p>算法：$fib(n) &#x3D; fib(n - 1) + fib(n - 2): {0, 1, 1, 2, 3, 5, 8, \cdots}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> &gt; n) ? n : <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>递推方程<br>$$<br>T(0) &#x3D; T(1) &#x3D; 1; ~ T(n) &#x3D; T(n - 1) + T(n - 2) + 1, n &gt; 1 \\</p>
<p>\begin{align}<br>S(n) &amp; &#x3D; \frac{T(n) + 1}{2} \[2ex]<br>S(0) &amp; &#x3D; 1 &#x3D; fib(1), S(1) &#x3D; 1 &#x3D; fib(2) \[2ex]<br>S(n) &amp; &#x3D; S(n - 1) + S(n - 2) &#x3D; fib(n + 1) \[2ex]<br>fib(n + 1) &amp; &#x3D; O(\Phi^n), \Phi &#x3D; \frac{1 + \sqrt{5}}{2} &#x3D; 1.61803\cdots \[2ex]<br>T(n) &#x3D; 2 * S(n) - 1 &amp; &#x3D; 2 * fib(n + 1) - 1 &#x3D; O(fib(n + 1)) &#x3D; O(\Phi^n) \[2ex]<br>\end{align} \[2ex]</p>
<p>T(n) &#x3D; O(2^n)<br>$$</p>
<blockquote>
<p>斐波那契数列的通项公式为 $F_n &#x3D; \dfrac{1}{\sqrt{5}}\left( \left( \dfrac{1 + \sqrt{5}}{2} \right)^n - \left( \dfrac{1 - \sqrt{5}}{2} \right)^n \right)$</p>
<p>例如：若求斐波那契第 $5$ 项，则 $f(5) &#x3D; f(4) + f(3) &#x3D; (f(3) + f(2)) + (f(2) + f(1)) &#x3D; \cdots &#x3D; 8$，则 $T(5) &#x3D; T(4) + T(3) + O(1) &#x3D; (T(3) + T(2) + O(1)) + (T(2) + T(1) + O(1)) + O(1) &#x3D; \cdots &#x3D; 15O(1)$。符合公式。</p>
<p>对于 $T(n) &#x3D; T(n - 1) + T(n - 2) + 1$ 中的 $1$，一方面，可以理解为递归次数（问题规模&#x2F;计算成本）$T(n)$ 为递归次数 $T(n - 1)$ 加上递归次数 $T(n - 2)$ 再加上自己递归了一次；另一方面，可以理解为 $T(n)$ 等于 $T(n - 1) + T(n - 2)$，再加上自己的复杂度 $O(1)$。这解释了”调用语句本身计入对应的子实例“，即在调用的时候将其看作一个整体，在进入调用函数后，计算它的时间成本。</p>
</blockquote>
</li>
<li><p>封底估算<br>$$<br>\begin{align}<br>\Phi^{36} &#x3D; 2^{25}, ~ &amp; \Phi^{43} &#x3D; 2^{30} &#x3D; 10^9 ~ flo &#x3D; 1 ~ sec \<br>\Phi^{5} &#x3D; 10, ~ &amp; \Phi^{67} &#x3D; 10^{14} ~ flo &#x3D; 10^5 ~ sec &#x3D; 1 ~ day \<br>&amp; \Phi^{92} &#x3D; 10^{19} ~ flo &#x3D; 10^{10} ~ sec &#x3D; 10^5 ~ day &#x3D; 3 ~ century<br>\end{align}<br>$$</p>
</li>
<li><p>递归跟踪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph</span><br><span class="line">	a(&quot;f(n)&quot;)</span><br><span class="line">	b(&quot;f(n - 1)&quot;)</span><br><span class="line">	c(&quot;f(n - 2)&quot;)</span><br><span class="line">	d(&quot;f(3)&quot;)</span><br><span class="line">	e(&quot;f(2)&quot;)</span><br><span class="line">	f(&quot;f(2)&quot;)</span><br><span class="line">	g(&quot;f(1)&quot;)</span><br><span class="line">	h(&quot;f(2)&quot;)</span><br><span class="line">	i(&quot;f(1)&quot;)</span><br><span class="line">	j(&quot;f(1)&quot;)</span><br><span class="line">	k(&quot;f(0)&quot;)</span><br><span class="line">	l(&quot;f(1)&quot;)</span><br><span class="line">	m(&quot;f(0)&quot;)</span><br><span class="line">	o(&quot;f(1)&quot;)</span><br><span class="line">	p(&quot;f(0)&quot;)</span><br><span class="line">	</span><br><span class="line">	a --&gt; b &amp; c</span><br><span class="line">	b .-&gt; d &amp; e</span><br><span class="line">	c .-&gt; f &amp; g</span><br><span class="line">	d --&gt; h &amp; i</span><br><span class="line">	e --&gt; j &amp; k</span><br><span class="line">	f --&gt; l &amp; m</span><br><span class="line">	h --&gt; o &amp; p</span><br></pre></td></tr></table></figure>

<ul>
<li>递归实例被大量重复地调用</li>
<li>空间复杂度 $O(n)$</li>
</ul>
</li>
<li><p>在只能一次上一阶或两阶的情况下，上到某层台阶有多少种走法。</p>
<ul>
<li>可以考虑为，上到第 $n$ 阶的前一步有可能在第 $n - 1$ 阶，通过上一阶的方式到第 $n$ 阶；有可能在第 $n - 2$ 阶，通过上两阶的方式到第 $n$ 阶。因此只需要统计到达第 $n - 1$ 阶有多少种走法，到达第 $n - 2$ 阶有多少种走法，将其相加即可。同理，可递归推断，直到上一阶是第零阶。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>$fib(n)$：迭代</p>
<ul>
<li><p>算法（记忆 Memorization）：将已计算过实例的结果制表备查。</p>
</li>
<li><p>算法（动态规划 Dynamic Programming）：颠倒计算方向，由自顶而下递归，改为自底而上递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    f = <span class="number">0</span>, g = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> &lt; n--) &#123;</span><br><span class="line">        g += f, f = g - f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度 $O(n)$，空间复杂度 $O(1)$</p>
<blockquote>
<p>最大栈深度为 $n$，由于栈调用后会释放，也就是最多占用 $n$ 个栈空间，所以空间复杂度为 $O(n)$。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-F2-动态规划：最长公共子序列"><a href="#01-F2-动态规划：最长公共子序列" class="headerlink" title="01-F2 动态规划：最长公共子序列"></a>01-F2 动态规划：最长公共子序列</h3><blockquote>
<p>01.Intro.F2.Dynamic_Programming.Lcs</p>
</blockquote>
<ul>
<li><p>LCS</p>
<ul>
<li>子序列（Subsequence）：由序列中若干字符，按原相对次序构成。</li>
<li>最长公共子序列（Longest Common Subsequence）：两个序列公共子序列中的最长者，可能有多个或有歧义。</li>
</ul>
</li>
<li><p>LCS：递归</p>
<ul>
<li><p>对于序列 $A[0, n]$ 和 $B[0, m]$，$\text{LCS}(A, B)$ 有三种情况</p>
<ul>
<li>若 $n &#x3D; -1$ 或 $m &#x3D; -1$，则取作空序列 $(\text{“”})$。即递归基。</li>
<li>若 $A[n] &#x3D; \text{‘X’} &#x3D; B[m]$，则取作 $\text{LCS}(A[0, n), B[0, m)) + \text{‘X’}$。即减而治之。</li>
<li>若 $A[n] \neq B[m]$，则在 $\text{LCS}(A[0, n], B[0, m))$ 与 $\text{LCS}(A[0, n), B[0, m])$ 中取更长者。即分而治之。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">LCS</span><span class="params">(string A, string B)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() == <span class="number">0</span> || B.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A.<span class="built_in">back</span>() == B.<span class="built_in">back</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = A.<span class="built_in">back</span>();</span><br><span class="line">        </span><br><span class="line">        A.<span class="built_in">pop_back</span>(), B.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCS</span>(A, B) + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        string a = <span class="built_in">LCS</span>(A, B.<span class="built_in">substr</span>(<span class="number">0</span>, B.<span class="built_in">size</span>() - <span class="number">1</span>)), b = <span class="built_in">LCS</span>(A.<span class="built_in">substr</span>(<span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>), B);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>() ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单调性：无论如何，每经过一次比对，原问题的规模必可减小。</p>
</li>
<li><p>最好情况下，只需要 $O(n + m)$ 时间。</p>
</li>
<li><h1 id="由于在第二种情况下，递归过程有大量雷同，最坏情况下，-text-LCS-A-0-a-B-0-B-出现的次数为-begin-pmatrix-n-m-a-b-n-a-end-pmatrix"><a href="#由于在第二种情况下，递归过程有大量雷同，最坏情况下，-text-LCS-A-0-a-B-0-B-出现的次数为-begin-pmatrix-n-m-a-b-n-a-end-pmatrix" class="headerlink" title="由于在第二种情况下，递归过程有大量雷同，最坏情况下，$\text{LCS}(A[0, a], B[0, B])$ 出现的次数为$$\begin{pmatrix}    n + m - a - b \    n - a\end{pmatrix}"></a>由于在第二种情况下，递归过程有大量雷同，最坏情况下，$\text{LCS}(A[0, a], B[0, B])$ 出现的次数为<br>$$<br>\begin{pmatrix}<br>    n + m - a - b \<br>    n - a<br>\end{pmatrix}</h1><h1 id="begin-pmatrix-n-m-a-b-m-b-end-pmatrix-特别地，-text-LCS-A-0-B-0-的次数为-begin-pmatrix-n-m-n-end-pmatrix"><a href="#begin-pmatrix-n-m-a-b-m-b-end-pmatrix-特别地，-text-LCS-A-0-B-0-的次数为-begin-pmatrix-n-m-n-end-pmatrix" class="headerlink" title="\begin{pmatrix}    n + m - a - b \    m - b\end{pmatrix}$$特别地，$\text{LCS}(A[0], B[0])$ 的次数为$$\begin{pmatrix}    n + m \    n\end{pmatrix}"></a>\begin{pmatrix}<br>    n + m - a - b \<br>    m - b<br>\end{pmatrix}<br>$$<br>特别地，$\text{LCS}(A[0], B[0])$ 的次数为<br>$$<br>\begin{pmatrix}<br>    n + m \<br>    n<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>n + m \<br>m<br>\end{pmatrix}<br>$$<br>当 $n &#x3D; m$ 时，为 $O(2^n)$。</p>
<blockquote>
<p>算法可以可视化的想象为一张表（假设两个序列分别为 $A &#x3D; \text{“abc”}, B &#x3D; \text{“def”}$）</p>
<table>
<thead>
<tr>
<th>$\text{LCS}(\text{“”}, \text{“”})$</th>
<th>$\text{LCS}(\text{“a”}, \text{“”})$</th>
<th>$\text{LCS}(\text{“ab”}, \text{“”})$</th>
<th>$\text{LCS}(\text{“abc”}, \text{“”})$</th>
</tr>
</thead>
<tbody><tr>
<td>$\text{LCS}(\text{“”}, \text{“d”})$</td>
<td>$\text{LCS}(\text{“a”}, \text{“d”})$</td>
<td>$\text{LCS}(\text{“ab”}, \text{“d”})$</td>
<td>$\text{LCS}(\text{“abc”}, \text{“d”})$</td>
</tr>
<tr>
<td>$\text{LCS}(\text{“”}, \text{“de”})$</td>
<td>$\text{LCS}(\text{“a”}, \text{“de”})$</td>
<td>$\text{LCS}(\text{“ab”}, \text{“de”})$</td>
<td>$\text{LCS}(\text{“abc”}, \text{“de”})$</td>
</tr>
<tr>
<td>$\text{LCS}(\text{“”}, \text{“def”})$</td>
<td>$\text{LCS}(\text{“a”}, \text{“def”})$</td>
<td>$\text{LCS}(\text{“ab”}, \text{“def”})$</td>
<td>$\text{LCS}(\text{“abc”}, \text{“def”})$</td>
</tr>
</tbody></table>
<p>从最后一行最后一列开始，算法的每次递归，都是选择向上和向左走一步，第一行第一列为递归基。</p>
<p>最好的情况下，算法每次都只向左上走，则至多需要 $O(\min{(n, m)})$ 时间。</p>
<p>最坏的情况下，算法每次都向上和向左走，则每一个递归实例出现的次数可以看作起点到终点的所有通路数量。</p>
<p>进而问题简化为，坐标系上原点开始某一点结束，每次只能水平或竖直行动一个单位，一共有多少种走法。对于此问题，可以看作 $x + y$ 步操作中任取 $x$ 步操作向水平走或任取 $y$ 步操作向竖直走，有多少种取法。因为不关心水平走操作之间的顺序，因此这是一个组合问题，解为 $C_{x + y}^x$ 或 $C_{x + y}^y$。</p>
<p>同理，对于本算法而言，最坏情况下某个递归实例出现次数为 $C_{n + m}^n$ 或 $C_{n + m}^m$。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>LCS：迭代</p>
<ul>
<li><p>递归算法会出现大量重复的递归实例，但递归实例一共只有 $n \times m$ 种，采用动态规划策略，$O(n * m)$ 的时间即可计算出所有子问题。</p>
</li>
<li><p>将所有子问题假想为一张表，从 $\text{LCS}(A[0], B[0])$ 出发，以此计算出所有项的结果。对于每个单元格，如果对应的元素相同，则取值为左上方单元格的值加一；如果不同，取大的值。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$x_3$</th>
<th>$x_4$</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>$y_1$</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$y_2$</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$y_3$</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">LCS</span><span class="params">(string A, string B)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> lenA = A.<span class="built_in">size</span>() + <span class="number">1</span>, lenB = B.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    string lcs[lenA][lenB];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lenB; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                lcs[i][j] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    lcs[i][j] = lcs[i - <span class="number">1</span>][j - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    lcs[i][j - <span class="number">1</span>].<span class="built_in">size</span>() &gt; lcs[i - <span class="number">1</span>][j].<span class="built_in">size</span>() ? lcs[i][j] = lcs[i][j - <span class="number">1</span>] : lcs[i][j] = lcs[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lcs[lenA - <span class="number">1</span>][lenB - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>递归：设计算法，证明可行；动态规划：消除重复，提高效率。</p>
</li>
</ul>
<h3 id="01-XA1-局限：缓存"><a href="#01-XA1-局限：缓存" class="headerlink" title="01-XA1 局限：缓存"></a>01-XA1 局限：缓存</h3><blockquote>
<p>01.Intro.XA1.Confine.Cache</p>
</blockquote>
<ul>
<li><p>就地循环移位：仅用 $O(1)$ 辅助空间，将数组 $A[0, n)$ 中的元素向左循环移动 $k$ 个单元。</p>
<ul>
<li><p>算法</p>
<ul>
<li><p>移位函数（$O(\dfrac{n}{\text{GCD(n, k)}})$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shift</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n, <span class="type">int</span> s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> b = A[s];</span><br><span class="line">    <span class="type">int</span> i = s, j = (s + k) % n;</span><br><span class="line">    <span class="type">int</span> mov = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (s != j) &#123;</span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        i = j;</span><br><span class="line">        j = (j + k) % n;</span><br><span class="line">        mov++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    A[i] = b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mov + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GCD：Greatest Common Divisor，最大公约数。</p>
<p>对于此算法，$n$ 代表序列的长度，$k$ 代表移了多少位。而它们的最大公约数 $g &#x3D; \text{GCD}(n, k)$，可以从两方面来理解，对于 $n$ 而言，表示需要进入循环的最小次数，即需要进行 $\dfrac{n}{g}$ 次循环，可以完成移位；对于 $k$ 而言，表示最小需要移位多少次才能回到起点，即从某点出发，移 $\dfrac{k}{g} + 1$ 次，回到起点，也即循环内部执行的次数。</p>
<p>从代码推导时间复杂度：</p>
<p>设从某一点出发，经过 $x$ 次移位，回到起点。这个过程可以等效为，将 $n$ 延长至原先的 $t$ 倍时，$(t \cdot n) ~ \text{mod} ~ k &#x3D; 0$。对于 $x$ 有 $x &#x3D; \dfrac{t \cdot n}{k}$。因此，经过一轮移位后，将有 $x$ 个元素被移至正确位置，那么，设一共需要进行 $y$ 轮循环，所有的元素都移至正确的位置。对于 $y$ 有 $y &#x3D; \dfrac{n}{x}$。联立两式，有 $y &#x3D; \dfrac{k}{t}$。因此，可以得到 $\dfrac{n}{y} &#x3D; x, \dfrac{k}{y} &#x3D; t$，也即 $n ~ \text{mod} ~ y &#x3D; 0, k ~ \text{mod} ~ y &#x3D; 0$，即 $y$ 是 $n$ 和 $k$ 的公约数。</p>
<p>由于存在关系 $(t \cdot n) ~ \text{mod} ~ k &#x3D; 0$，那么存在设 $t_0$ 是 $t$ 由 $1$ 开始以 $1$ 为步长递增时，第一个满足关系的值，那么可知 $t$ 的取值集合 ${t_n}$ 有 ${t_n} &#x3D; n \cdot t_0, n \in N^+$。因为程序执行时，每移一次位，都会判断是否回到起点，因此找到的移位次数 $x$ 一定是最小的，也即 $t \cdot \dfrac{n}{k}$ 是最小的，由于 $n, k$ 是确定值，则对应于 $x_{min}$ 的 $t$ 为 $t_{min}$，并且 $t_{min} &#x3D; \min{t_n} &#x3D; t_0$。根据 $x &#x3D; \dfrac{n}{y}, t &#x3D; \dfrac{k}{y}$，同时使 $x &#x3D; x_{min}, t &#x3D; t_{min}$ 的 $y$ 值，一定是 $x$ 和 $t$ 公约数中最大的，即程序找到的 $y$ 为最大公约数 $g$。</p>
<p>此时，</p>
<p><code>shift</code> 函数的时间复杂度为 $O(x) &#x3D; O(\dfrac{n}{g})$。</p>
<p><code>shift0</code> 函数的时间复杂度为 $O(k \times x) &#x3D; O(k \times \dfrac{n}{g})$，因为每次只移动一位，$k &#x3D; 1, t &#x3D; 1$，则 $g &#x3D; 1$，$O &#x3D; O(k \times n)$。</p>
<p><code>shift1</code> 函数中，观察可知每次调用 <code>shift</code> 函数后，$mov$ 的值为 $x \cdot i, ~ i &#x3D; 1, 2, \cdots$，$i$ 表示当前已经执行 $i$ 轮移位。因此，循环结束的条件为 $mov &#x3D; x \cdot i \geqslant n$，即 $i \geqslant \dfrac{n}{x} &#x3D; y$，$i$ 取最小值，$i_{min} &#x3D; y$，即循环结束时，已经进行 $y$ 轮移位，符合 $y$ 的定义，说明程序能够完成任务。此时，时间复杂度为 $O(xy) &#x3D; O(\dfrac{n}{g} \cdot g) &#x3D; O(n)$。</p>
</blockquote>
</li>
<li><p>蛮力版（$O(n \times k)$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift0</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">shift</span>(A, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代版（$O(n)$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift1</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>, mov = <span class="number">0</span>; mov &lt; n; s++) &#123; <span class="comment">// O(g)</span></span><br><span class="line">        mov += <span class="built_in">shift</span>(A, n, s, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>倒置版（$O(3n)$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift2</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(A, k); <span class="comment">// O(3k / 2)</span></span><br><span class="line">    <span class="built_in">reverse</span>(A + k, n - k); <span class="comment">// O(3(n - k) / 2)</span></span><br><span class="line">    <span class="built_in">reverse</span>(A, n); <span class="comment">// O(3n / 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>reverse(A, n)</code> 函数执行时，需要对 $\dfrac{n}{2}$ 对数据进行操作，并且对于每一对数据，交换值需要 $3$ 次操作，因此共需要 $\dfrac{3n}{2}$ 次操作。</p>
</blockquote>
<ul>
<li>这个版本效率最高，因为 <code>reverse()</code> 的操作是在连续的数据上。</li>
<li>根据 Cache 缓存机制，注意数据访问次序。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>DSA</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学</title>
    <url>/2023/04/06/math/</url>
    <content><![CDATA[<h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="第-1-章-极限与连续"><a href="#第-1-章-极限与连续" class="headerlink" title="第 1 章 极限与连续"></a>第 1 章 极限与连续</h2><h3 id="1-1-函数"><a href="#1-1-函数" class="headerlink" title="1.1 函数"></a>1.1 函数</h3><h4 id="1-1-1-集合"><a href="#1-1-1-集合" class="headerlink" title="1.1.1 集合"></a>1.1.1 集合</h4><ul>
<li><p><strong>定义 1.1</strong></p>
<p>​		设 $x_0$ 为一实数，$\delta$ 是某一正数，称开区间 $(x_0 - \delta, x_0 + \delta)$ 为 $x_0$ 的 $\delta$ <strong>邻域</strong>，记为 $U(x_0, \delta)$，点 $x_0$ 称为邻域的<strong>中心</strong>，$\delta$ 称为邻域的<strong>半径</strong>。开区间 $(x_0 - \delta, x_0)$ 称为 $x_0$ 的<strong>左侧</strong> $\delta$ <strong>邻域</strong>，开区间 $(x_0, x_0 + \delta)$ 称为 $x_0$ 的<strong>右侧</strong> $\delta$ <strong>邻域</strong>。</p>
<p>​		如果把邻域的中心去掉，得到的集合 $(x_0 - \delta, x_0) \cup (x_0, x_0 + \delta)$ 称为 $x_0$ 的<strong>去心</strong> $\delta$ <strong>邻域</strong>，记为 $\mathring{U}(x_0, \delta)$。不需要强调邻域的半径 $\delta$ 时，则用 $U(x_0)$ 表示点 $x_0$ 的某个邻域，$\mathring{U}(x_0)$ 表示点 $x_0$ 的某个去心邻域。</p>
</li>
<li><p><strong>定义 1.2</strong></p>
<p>​		设 $E$ 是一个集合。如果存在 $M &gt; 0$，对于任意给定的 $x \in E$，都有 $\lvert ~ x ~ \rvert \leqslant M$，则称 $E$ 是<strong>有界集合</strong>。 如果这样的 $M &gt; 0$ 不存在，则称 $E$ 是<strong>无界集合</strong>。如果存在 $M$，对于任意给定的 $x \in E$，有 $x \leqslant M$，则称 $E$ 是<strong>上方有界集合</strong>。如果存在 $M$，对于任意给定的 $x \in E$，有 $x \geqslant M$，则称 $E$ 是<strong>下方有界集合</strong>。</p>
</li>
</ul>
<h4 id="1-1-2-函数的定义"><a href="#1-1-2-函数的定义" class="headerlink" title="1.1.2 函数的定义"></a>1.1.2 函数的定义</h4><ul>
<li><p><strong>定义 1.3</strong></p>
<p>​		设 $D$ 是一个数集，$f$ 是一个对应关系。如果对于任意给定的 $x \in D$，由关系 $f$ 可以唯一确定一个实数 $y$ 与 $x$ 对应，则称 $f$ 确定了 $D$ 上的一个<strong>函数</strong>，用 $y &#x3D; f(x)$ 表示，其中 $x$ 称为<strong>自变量</strong>，$y$ 称为<strong>因变量</strong>，$D$ 称为<strong>定义域</strong>，$f(x)$ 的全体函数值所构成的集合称为函数的<strong>值域</strong>，用 $R(f)$ 表示。</p>
<blockquote>
<p>函数单调则一定有反函数，且二者单调性相同；</p>
<p>连续不一定可导，可导必连续。</p>
</blockquote>
</li>
</ul>
<h4 id="1-1-3-函数的表达方式"><a href="#1-1-3-函数的表达方式" class="headerlink" title="1.1.3 函数的表达方式"></a>1.1.3 函数的表达方式</h4><blockquote>
<p><strong>注</strong>	反三角函数：反正弦函数 $y &#x3D; \arcsin x$，定义域 $[-1, 1]$，值域 $[-\dfrac{\pi}{2}, \dfrac{\pi}{2}]$；反余弦函数 $y &#x3D; \arccos x$，定义域 $[-1, 1]$，值域 $[0, \pi]$；反正切函数 $y &#x3D; \arctan x$，定义域 $[-\infty, +\infty]$，值域 $(-\dfrac{\pi}{2}, \dfrac{\pi}{2})$。</p>
</blockquote>
<h4 id="1-1-4-函数的基本特性"><a href="#1-1-4-函数的基本特性" class="headerlink" title="1.1.4 函数的基本特性"></a>1.1.4 函数的基本特性</h4><ul>
<li><p><strong>定义 1.4</strong> — 有界性</p>
<p>​		设函数 $f(x)$ 的定义域为 $I$，若存在数 $M$，对于任意的 $x \in I$，$f(x) \leqslant M$ 总成立，则称函数 $f(x)$ 在 $I$ 上有<strong>上界</strong>，$M$ 为 $f(x)$ 在 $I$ 上的一个上界。若存在数 $m$，对于任意 $x \in I$，$f(x) \geqslant m$ 总成立，则称函数 $f(x)$ 在 $I$ 上有<strong>下界</strong>，$m$ 为 $f(x)$ 在 $I$ 上的一个下界。</p>
<p>​		若存在 $M &gt; 0$，对于任意的 $x \in I$，$\lvert ~ f(x) ~ \rvert \leqslant M$ 总成立，则称函数 $f(x)$ 在 $I$ 上<strong>有界</strong>。如果这样的数 $M$ 不存在，则称函数 $f(x)$ 在 $I$ 上<strong>无界</strong>。这就是说如果对于任何正数 $M$，总存在 $x_0 \in I$，使得 $\lvert ~ f(x_0) ~ \rvert &gt; M$，那么函数 $f(x)$ 在 $I$ 上无界。</p>
</li>
<li><p><strong>定义 1.5</strong> — 奇偶性</p>
<p>​		设函数 $f(x)$ 在关于原点对称的数集 $I$ 上有定义。若对于任意的 $x \in I$，$f(x) &#x3D; f(-x)$ 成立，称 $f(x)$ 为<strong>偶函数</strong>，若 $f(x) &#x3D; - f(-x)$ 成立，称 $f(x)$ 为奇函数。</p>
</li>
<li><p><strong>定义 1.6</strong> — 单调性</p>
<p>​		设函数 $f(x)$ 的定义域为 $I$，如果对于任意的 $x_1, x_2 \in I, x_1 &lt; x_2$，都有 $f(x_1) \leqslant f(x_2)$，称 $f(x)$ 是 $I$ 上的<strong>单调不减函数**。如果对于任意的 $x_1, x_2 \in I, x_1 &lt; x_2$，都有 $f(x_1) &lt; f(x_2)$，则称 $f(x)$ 是 $I$ 上的**单调递增函数**。若对于任意的 $x_1, x_2 \in I, x_1 &lt; x_2$，都有 $f(x_1) \geqslant f(x_2)$，称 $f(x)$ 为 $I$ 上的**单调不增函数**。如果对于任意的 $x_1, x_2 \in I, x_1 &lt; x_2$，都有 $f(x_1) &gt; f(x_2)$，则称 $f(x)$ 是 $I$ 上的</strong>单调递减函数**。</p>
</li>
<li><p><strong>定义 1.7</strong> — 周期性</p>
<p>​		设函数 $f(x)$ 在 $I$ 上有定义，$T$ 是一正数。如果对于任意的 $x \in I$ 都有 $x + T \in I$ 且 $f(x + T) &#x3D; f(x)$ 成立，则称 $f(x)$ 是以 $T$ 为周期的<strong>周期函数</strong>。如果存在 $T_0 &gt; 0$ 是使 $f(x + T) &#x3D; f(x)$ 成立的最小正数，则称 $T_0$ 为 $f(x)$ 的<strong>最小正周期</strong>。</p>
<blockquote>
<p><strong>注</strong>	不一定有最小正周期，例如常值函数、狄利克雷函数。</p>
</blockquote>
</li>
</ul>
<h4 id="1-1-5-函数的运算"><a href="#1-1-5-函数的运算" class="headerlink" title="1.1.5 函数的运算"></a>1.1.5 函数的运算</h4><ul>
<li><p><strong>定义 1.8</strong></p>
<p>​		设函数 $f(x), g(x)$ 在 $I$ 上有定义，称 $f(x) + g(x)$ 为函数 $f(x)$ 与 $g(x)$ 的<strong>和函数</strong>，称 $f(x) - g(x)$ 为函数 $f(x)$ 与 $g(x)$ 的<strong>差函数</strong>。 </p>
</li>
<li><p><strong>定义 1.9</strong></p>
<p>​		设函数 $f(x), g(x)$ 在 $I$ 上有定义，称 $f(x)g(x)$ 为函数 $f(x)$ 与 $g(x)$ 的<strong>积函数</strong>。</p>
</li>
<li><p><strong>定义 1.10</strong></p>
<p>​		设函数 $f(x), g(x)$ 在 $I$ 上有定义，称<br>$$<br>\frac{f(x)}{g(x)} ~ (其中 ~ g(x) \neq 0)<br>$$<br>为函数 $f(x)$ 与 $g(x)$ 的<strong>商函数</strong>。</p>
</li>
</ul>
<blockquote>
<p>在定义域交集上运算。</p>
</blockquote>
<ul>
<li><p><strong>定义 1.11</strong></p>
<p>​		设函数 $f(x)$ 在 $I_1$ 上有定义，函数 $x &#x3D; g(t)$ 在 $I_2$ 上有定义，且对于任意给定的 $t \in I_2, g(t) \in I_1$。$f \circ g$ 定义如下：对于任意的 $t \in I_2$，$f \circ g(t) &#x3D; f(g(t))$，则称 $f \circ g(t)$ 为函数 $f(x)$ 与 $g(t)$ 的<strong>复合函数</strong>，通常将 $f \circ g(t)$ 用 $f(g(t))$ 表示。</p>
</li>
</ul>
<h4 id="1-16-初等函数"><a href="#1-16-初等函数" class="headerlink" title="1.16 初等函数"></a>1.16 初等函数</h4><ul>
<li><p><strong>定义 1.12</strong></p>
<p>​		由常数和基本初等函数经过有限次的四则运算及复合过程所得到的可以用一个式子表示的函数称为<strong>初等函数</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>注</strong>	三角函数公式：</p>
<p>$\sin (\alpha \pm \beta) &#x3D; \sin\alpha \cos\beta \pm \sin\beta \cos\alpha$；</p>
<p>$\cos(\alpha \pm \beta) &#x3D; \cos\alpha \cos\beta \mp \sin\alpha \sin\beta$；</p>
<p>$\sin 2\alpha &#x3D; 2 \sin\alpha \cos\alpha$；</p>
<p>$\cos 2 \alpha &#x3D; \cos^2 \alpha - \sin^2 \alpha &#x3D; 2 \cos^2\alpha - 1 &#x3D; 1 - 2 \sin^2\alpha$；</p>
<p>$\sin\alpha - \sin\beta &#x3D; 2 \sin\dfrac{\alpha - \beta}{2} \cos\dfrac{\alpha + \beta}{2}$；</p>
<p>$\cos\alpha - \cos\beta &#x3D; -2 \sin\dfrac{\alpha - \beta}{2} \cos\dfrac{\alpha + \beta}{2}$；</p>
<p>$\sin\alpha \cos\beta &#x3D; \dfrac{1}{2}(\sin(\alpha + \beta) + \sin(\alpha - \beta))$；</p>
<p>$\sin\alpha \sin\beta &#x3D; -\dfrac{1}{2}(\cos(\alpha + \beta) - \cos(\alpha - \beta))$；</p>
<p>$\cos\alpha \cos\beta &#x3D; \dfrac{1}{2} (\cos(\alpha + \beta) + \cos(\alpha - \beta))$；</p>
</blockquote>
<h3 id="1-2-数列的极限"><a href="#1-2-数列的极限" class="headerlink" title="1.2 数列的极限"></a>1.2 数列的极限</h3><h4 id="1-2-1-数列"><a href="#1-2-1-数列" class="headerlink" title="1.2.1 数列"></a>1.2.1 数列</h4><ul>
<li><p><strong>定义 1.13</strong></p>
<p>​		若函数 $y &#x3D; f(x)$ 在正整数集 $N_+$ 上有定义，记 $x_n &#x3D; f(n), n \in N_+$，称 $x_1, x_2, \cdots, x_n, \cdots$ 为<strong>数列</strong>，记为 ${x_n}$，其中 $x_n$ 称为数列的<strong>通项</strong>或<strong>一般项</strong>。</p>
</li>
<li><p><strong>定义 1.14</strong></p>
<p>​		对于数列 $x_n$，如果存在 $M &gt; 0$，对于任意正整数 $n$，有 $\lvert ~ x_n ~ \rvert \leqslant M$，则称数列 ${x_n}$ 为<strong>有界数列</strong>。如果这样的 $M$ 不存在，则称数列 ${x_n}$ 为<strong>无界数列</strong>。如果存在实数 $M$，对于任意正整数 $n$，$x_n \leqslant M$ 成立，则称数列 ${x_n}$ <strong>上方有界</strong>，否则，称 ${x_n}$ 上方无界。如果存在实数 $m$，对于任意正整数 $n$，$x_n \geqslant m$ 成立，则称数列 ${x_n}$ <strong>下方有界</strong>，否则，称 ${x_n}$ 下方无界。</p>
</li>
<li><p><strong>定义 1.15</strong></p>
<p>​		设 ${x_n}$ 是一个数列，如果对于任意的 $n$，都有 $x_{n + 1} &gt; x_n$，则称 ${x_n}$ 是单调递增的数列。反之，如果对于任意的 $n$，都有 $x_{n + 1} &lt; x_n$，则称 ${x_n}$ 是单调递减的数列。</p>
</li>
</ul>
<h4 id="1-2-2-数列的极限"><a href="#1-2-2-数列的极限" class="headerlink" title="1.2.2 数列的极限"></a>1.2.2 数列的极限</h4><ul>
<li><p><strong>定义 1.16</strong></p>
<p>​		设 ${x_n}$ 是一个数列，$a$ 为一个常数。如果对于任意给定的 $\varepsilon &gt; 0$，总存在正整数 $N$，使得对于 $n &gt; N$ 时的一切 $x_n$，不等式<br>$$<br>\lvert ~ x_n - a ~ \rvert &lt; \varepsilon<br>$$<br>都成立，那么就称常数 $a$ 是数列 ${x_n}$ 的<strong>极限</strong>，或者称数列 ${x_n}$ <strong>收敛于</strong> $a$，记为<br>$$<br>\lim_{n \to \infty} x_n &#x3D; a ~ 或 ~ x_n \to a ~ (n \to \infty).<br>$$<br>​		如果数列没有极限，就说数列是<strong>发散</strong>的。</p>
<blockquote>
<p><strong>注</strong>	数列本质上是一系列离散的点的集合，因此不存在趋于某一点的说法。另一方面来说，极限和“趋于”这两个词，都是隐含连续意味的。</p>
<p>数列极限定义中的 $N$ 和 $\varepsilon$ 有关，但 $N$ 并不是 $\varepsilon$ 的函数。一般来说，因变量是自变量的函数，即因变量随着自变量的变化而变化，且对于每一个确定的自变量，都有唯一确定的一个因变量与之对应。这里所说 $N$ 不是 $\varepsilon$ 的函数，是因为虽然 $\varepsilon$ 的取值越小，$N$ 的取值越大，$N$ 会随着 $\varepsilon$ 的变化而变化，但是对于某个确定的 $\varepsilon$ 值，$N$ 可以取无数个值，因此二者不是函数关系。</p>
<p>定义中的 $\varepsilon &gt; 0$ 表示 $x_n$ 与 $a$ 的接近程度，$N$ 是和 $\varepsilon$ 有关的正整数，表示 $n$ 趋于无穷的程度，因此它不一定是最小的值。定义的另一种理解是，数列中从第 $N + 1$ 项开始，所有项都落在 $U(a, \varepsilon)$ 中，且区间 $(a - \varepsilon, a + \varepsilon)$ 的长度可以任意缩小。</p>
<p>数列 ${x_n}$ 收敛与否以及收敛数列的极限是什么，与数列前有限项无关，改变前有限项的值，也不影响敛散性和极限。这点在后面证明收敛数列的有界性会用到。</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-3-收敛数列的性质"><a href="#1-2-3-收敛数列的性质" class="headerlink" title="1.2.3 收敛数列的性质"></a>1.2.3 收敛数列的性质</h4><ul>
<li><p><strong>定理 1.1</strong> — 极限的唯一性</p>
<p>​		收敛数列的极限是唯一的。</p>
<p><strong>证</strong>	用反证法，设 $\lim\limits_{n \to \infty} x_n &#x3D; a, \lim\limits_{n \to \infty} x_n &#x3D; b$。若结论不真，即 $a \neq b$，不妨设 $a &lt; b$，于是 $b - a &gt; 0$。取 $\varepsilon &#x3D; \dfrac{b - a}{2} &gt; 0$，对于 $\lim\limits_{n \to \infty} x_n &#x3D; a$，由数列极限定义知，存在正整数 $N_1$，当 $n &gt; N_1$ 时，有<br>$$<br>\lvert ~ x_n - a ~ \rvert &lt; \varepsilon &#x3D; \frac{b - a}{2},<br>$$<br>即<br>$$<br>\frac{3a - b}{2} &lt; x_n &lt; \frac{a + b}{2}. ~ (1)<br>$$</p>
<p>​		同理，对于 $\lim\limits_{n \to \infty} x_n &#x3D; b$，存在正整数 $N_2$，当 $n &gt; N_2$ 时，有<br>$$<br>\lvert ~ x_n - b ~ \rvert &lt; \varepsilon &#x3D; \frac{b - a}{2},<br>$$<br>即<br>$$<br>\frac{a + b}{2} &lt; x_n &lt; \frac{3b - a}{2}. ~ (2)<br>$$<br>​		取 $N &#x3D; \max{N_1, N_2}$，当 $n &gt; N$ 时，式 $(1)$ 和 $(2)$ 同时成立，由式 $(1)$ 有 $x_n &lt; \dfrac{a + b}{2}$，由式 $(2)$ 有 $x_n &gt; \dfrac{a + b}{2}$，矛盾。所以极限唯一。</p>
</li>
<li><p><strong>定理 1.2</strong> — 收敛数列的有界性</p>
<p>​		设 $\lim\limits_{n \to \infty} x_n &#x3D; a$，则 ${x_n}$ 有界，即存在 $M &gt; 0$，对任意的 $n$，有 $\lvert ~ x_n ~ \rvert \leqslant M$。</p>
<p><strong>证</strong>	由 $\lim\limits_{n \to \infty} x_n &#x3D; a$ 知，对任意 $\varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$。特别地，取 $\varepsilon_0 &#x3D; 1$，存在正整数 $N_0$，当 $n &gt; N_0$ 时，有 $\lvert ~ x_n - a ~ \rvert &lt; 1$。于是当 $n &gt; N_0$ 时，$\lvert ~ x_n ~ \rvert \leqslant \lvert ~ x_n - a ~ \rvert + \lvert ~ a ~ \rvert &lt; \lvert ~ a ~ \rvert + 1$。取 $M &#x3D; \max{\lvert ~ x_1 ~ \rvert, \lvert ~ x_2 ~ \rvert, \cdots, \lvert ~ x_{N_0} ~ \rvert, \lvert ~ a ~ \rvert + 1}$，那么，对任意的 $n$ 有 $\lvert ~ x_n ~ \rvert \leqslant M$。这说明 ${x_n}$ 有界。</p>
<blockquote>
<p><strong>注</strong>	对于一个收敛数列，取特定 $\varepsilon$ 值时，其某项之后都小于 $\varepsilon$，而其前 $n$ 项无论多大，都会是一个具体的、可描述的数值，因此它一定有界，即使这个“界”大的无法想象。另一方面来说， $\infty$ 是抽象的、不可描述的、不单单表示非常大或非常小的概念。</p>
<p>收敛数列一定有界，有界数列不一定收敛，例如 $x_n &#x3D; \dfrac{(-1)^n n}{1 + n}$；</p>
<p>无界数列一定发散，发散数列不一定无界；</p>
<p>无穷大一定是无界数列，无界数列不一定是无穷大，例如 $x_n &#x3D; n + (-1)^n n$。</p>
<p>无穷大数列：对于任意正数 $M &gt; 0$，总存在正整数 $N$，使得当 $n &gt; N$ 时，有 $\lvert ~ x_n ~ \rvert &gt; M$。无穷大暗含递增的意思。</p>
</blockquote>
</li>
<li><p><strong>定义 1.17</strong></p>
<p>​		设 ${x_n}$ 是一个数列，$n_1, n_2, n_3, \cdots$ 是单调递增的正整数数列，称数列 $x_{n_1}, x_{n_2}, x_{n_3}, \cdots$ 为 ${x_n}$ 的一个<strong>子列</strong>。</p>
</li>
<li><p><strong>定理 1.3</strong> — 数列收敛和其子列收敛的关系（一）</p>
<p>​		设 $\lim\limits_{n \to \infty} x_n &#x3D; a$，${x_{n_k}}$ 为 ${x_n}$ 的子列，则 $\lim\limits_{k \to \infty} x_{n_k} &#x3D; a$。</p>
<p><strong>证</strong>	由 $\lim\limits_{n \to \infty} x_n &#x3D; a$，对于任意给定的 $\varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$。当 $k &gt; N$ 时，有 $n_k \geqslant k &gt; N$，则 $\lvert ~ x_{n_k} - a ~ \rvert &lt; \varepsilon$，这说明 $\lim\limits_{k \to \infty} x_{n_k} &#x3D; a$。</p>
<blockquote>
<p><strong>注</strong>	因为由条件可知 $n &gt; N$ 时都有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$。另由 ${x_{n_k}}$ 为 ${x_n}$ 的子列，且下标数列 $n_k$ 单调递增，则子列第 $k$ 项的下标 $n_k &gt;&#x3D; k$，当取 $k &gt; N$ 时，推出 $n_k &gt; N$，此时再由前述可知 $\lvert ~ x_{n_k} - a ~ \rvert &lt; \varepsilon$。证明过程本质是将原式的 $n$ 换成 $n_k$ 并进行反推。</p>
<p>可利用此定理，通过找到发散的子列或找两个收敛到不同值的子列，证明数列极限不存在。</p>
<p>进一步说明，一个数列收敛，则其所有的子列均收敛；而子列收敛，数列不一定收敛，当两个收敛子列极限不同时，数列一定不收敛；若子列发散，根据第一条性质，数列一定不收敛。</p>
</blockquote>
</li>
<li><p><strong>定理 1.4</strong> — 数列收敛和其子列收敛的关系（二）</p>
<p>​		对于数列 ${x_n}$，如果 $\lim\limits_{k \to \infty} x_{2k - 1} &#x3D; \lim\limits_{k \to \infty} x_{2k} &#x3D; a$，则 $\lim\limits_{n \to \infty} x_n &#x3D; a$。</p>
<p><strong>证</strong>	由 $\lim\limits_{k \to \infty} x_{2k - 1} &#x3D; a$，对于任意给定的 $\varepsilon &gt; 0$，存在正整数 $K_1$，当 $k &gt; K_1$ 时，有 $\lvert ~ x_{2k - 1} - a ~ \rvert &lt; \varepsilon$。同理，由 $\lim\limits_{k \to \infty} x_{2k} &#x3D; a$，对于任意给定的 $\varepsilon &gt; 0$，存在正整数 $K_2$，当 $k &gt; K_2$ 时，有 $\lvert ~ x_{2k} - a ~ \rvert &lt; \varepsilon$。取 $n &gt; N &#x3D; \max{2K_1 - 1, 2K_2}$，则有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$，即得 $\lim\limits_{n \to \infty} x_n &#x3D; a$。</p>
<blockquote>
<p><strong>注</strong>	当取 $n &gt; N &#x3D; \max{2K_1 - 1, 2K_2}$ 时，$n$ 的值同时满足上述两个不等式，将 ${x_{2k - 1}}$ 和 ${x_{2k}}$ 求并集得到 ${x_n}$，因此 ${x_n}$ 满足 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$。</p>
<p>可以利用此定理证明某些极限的存在性。</p>
</blockquote>
</li>
<li><p><strong>定理 1.5</strong> — 收敛数列的保号性</p>
<p>​		设 $\lim\limits_{n \to \infty} x_n &#x3D; a &gt; 0$（或 $a &lt; 0$），则存在正整数 $N_0$，当 $n &gt; N_0$ 时，有 $x_n &gt; 0$（或 $x_n &lt; 0$）。</p>
<p><strong>证</strong>	由 $\lim\limits_{n \to \infty} x_n &#x3D; a &gt; 0$，则对任意的 $\varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$。特别地，若取 $\varepsilon &#x3D; a$，存在正整数 $N_0$，当 $n &gt; N_0$ 时，$\lvert ~ x_n - a ~ \rvert &lt; a$。这样便有 $x_n &gt; 0$ 成立。同理可证 $a &lt; 0$ 的情况。</p>
<blockquote>
<p><strong>注</strong>	取 $\varepsilon &#x3D; a$，得到 $\lvert ~ x_n - a ~ \rvert &lt; a$，又得 $-a &lt; x_n - a &lt; a$，即 $0 &lt; x_n &lt; 2a$。</p>
<p>定理的逆推不成立，因为极限有可能为 $0$，例如 $x_n &#x3D; \dfrac{1}{n}$。</p>
</blockquote>
<ul>
<li><p><strong>推论 1</strong></p>
<p>​		设 $\lim\limits_{n \to \infty} x_n &#x3D; a$，则对于任意 $b &lt; a$，存在正整数 $N_0$，当 $n &gt; N_0$ 时，$x_n &gt; b$。</p>
<p><strong>证</strong>	由 $\lim\limits_{n \to \infty} x_n &#x3D; a &gt; b$，则对任意的 $\varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$。若取 $\varepsilon &#x3D; a - b$，存在正整数 $N_0$，当 $n &gt; N_0$ 时，$\lvert ~ x_n - a ~ \rvert &lt; a - b$。解得 $b &lt; x &lt; 2a - b$。</p>
</li>
<li><p><strong>推论 2</strong></p>
<p>​		设 $\lim\limits_{n \to \infty} x_n &#x3D; a$，则对于任意 $b &gt; a$，存在正整数 $N_0$，当 $n &gt; N_0$ 时，$x_n &lt; b$。</p>
</li>
</ul>
</li>
<li><p><strong>定理 1.6</strong> — 收敛数列的保序性</p>
<p>​		设 $x_n \leqslant y_n$，如果 $\lim\limits_{n \to \infty} x_n &#x3D; a, \lim\limits_{n \to \infty} y_n &#x3D; b$，则有 $a \leqslant b$。</p>
<p><strong>证</strong>	反证法，若结论不真，则 $a &gt; b$，有 $a - b &gt; 0$，取 $\varepsilon &#x3D; \dfrac{a - b}{2} &gt; 0$ 。由 $\lim\limits_{n \to \infty} x_n &#x3D; a$，存在正整数 $N_1$，当 $n &gt; N_1$ 时，有<br>$$<br>\lvert ~ x_n - a ~ \rvert &lt; \varepsilon &#x3D; \dfrac{a - b}{2},<br>$$<br>即<br>$$<br>\frac{a + b}{2} &lt; x_n &lt; \frac{3a - b}{2}. ~(1)<br>$$<br>​		同理，由 $\lim\limits_{n \to \infty} y_n &#x3D; b$，存在正整数 $N_2$，当 $n &gt; N_2$ 时，有<br>$$<br>\lvert ~ y_n - b ~ \rvert &lt; \varepsilon &#x3D; \frac{a - b}{2},<br>$$<br>即<br>$$<br>\frac{3b - a}{2} &lt; y_n &lt; \frac{a + b}{2}. ~ (2)<br>$$<br>​		取 $n &gt; N &#x3D; \max {N1, N2}$，则式 $(1)$ 和式 $(2)$ 同时成立，有 $y_n &lt; \dfrac{a + b}{2} &lt; x_n$，与题设 $x_n \leqslant y_n$ 矛盾，所以 $a \leqslant b$。</p>
<blockquote>
<p><strong>注</strong>	若 $x_n &lt; y_n$，未必有 $\lim\limits_{n \to \infty} x_n &lt; \lim\limits_{n \to \infty} y_n$。例如 $x_n &#x3D; \dfrac{1}{2n}, y_n &#x3D; \dfrac{1}{n}$，虽然 $x_n &lt; y_n$，但 $\lim\limits_{n \to \infty} x_n &#x3D; \lim\limits_{n \to \infty} y_n &#x3D; 0$。</p>
</blockquote>
</li>
<li><p><strong>定理 1.7</strong> — 极限的夹逼定理</p>
<p>​		设数列 ${x_n}, {z_n}, {y_n}$ 满足：$(1) ~ x_n \leqslant z_n \leqslant y_n; (2) ~ \lim\limits_{n \to \infty} x_n &#x3D; \lim\limits_{n \to \infty} y_n &#x3D; a$。则 $\lim\limits_{n \to \infty} z_n$ 存在，且 $\lim\limits_{n \to \infty} z_n &#x3D; a$。</p>
<p><strong>证</strong>	因 $\lim\limits_{n \to \infty} x_n &#x3D; a$，则 $\forall ~ \varepsilon &gt; 0$，$\exists ~ N_1 \in N_+$，当 $n &gt; N_1$ 时，有 $\lvert ~ x_n - a ~ \rvert &lt; \varepsilon$，即<br>$$<br>a - \varepsilon &lt; x_n &lt; a + \varepsilon. ~ (1)<br>$$<br>又 $\lim\limits_{n \to \infty} y_n &#x3D; a$，对上述 $\varepsilon$，$\exists ~ N_2 \in N_+$，当 $n &gt; N_2$ 时，有 $\lvert ~ y_n - a ~ \rvert &lt; \varepsilon$，即<br>$$<br>a - \varepsilon &lt; y_n &lt; a + \varepsilon. ~ (2)<br>$$<br>​		取 $N &#x3D; \max{N_1, N_2}$，当 $n &gt; N$ 时，式 $(1)$ 与 $(2)$ 同时成立。又 $x_n \leqslant z_n \leqslant y_n$，于是当 $n &gt; N$ 时，<br>$$<br>a - \varepsilon &lt; x_n \leqslant z_n \leqslant y_n &lt; a + \varepsilon,<br>$$<br>即<br>$$<br>\lvert ~ z_n - a ~ \rvert &lt; \varepsilon.<br>$$<br>从而 $\lim\limits_{n \to \infty} z_n &#x3D; a$。</p>
<blockquote>
<p><strong>注</strong>	这里条件中的 $x_n \leqslant z_n \leqslant y_n$ 只需要从某一项开始成立即可。</p>
</blockquote>
</li>
</ul>
<h3 id="1-3-函数的极限"><a href="#1-3-函数的极限" class="headerlink" title="1.3 函数的极限"></a>1.3 函数的极限</h3><h4 id="1-3-1-自变量趋于有限值时函数的极限"><a href="#1-3-1-自变量趋于有限值时函数的极限" class="headerlink" title="1.3.1 自变量趋于有限值时函数的极限"></a>1.3.1 自变量趋于有限值时函数的极限</h4><ul>
<li><p><strong>定义 1.18</strong></p>
<p>​		设函数 $f(x)$ 在 $x_0$ 的某个去心邻域 $\mathring{U}(x, \delta_0)$ 内有定义，$A$ 为一常数，如果对于任意给定的 $\varepsilon &gt; 0$，总存在 $0 &lt; \delta \leqslant \delta_0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon$ 总成立，则称函数 $f(x)$ 当 $x$ 趋于 $x_0$ 时以 $A$ 为极限，记为 $\lim\limits_{x \to x_0} f(x) &#x3D; A$ 或 $f(x) \to A(x - x_0)$。</p>
<blockquote>
<p><strong>注</strong>	$\lim\limits_{x \to x_0}f(x) &#x3D; A$ 研究的是函数 $f(x)$ 在 $x_0$ 点附近的函数值随 $x$ 的变化情况，$\lim\limits_{x \to x_0} f(x)$ 存在与否以及存在时极限值是多少，都与 $f(x)$ 在 $x_0$ 点有无定义以及有定义时函数值是多少无关。</p>
</blockquote>
</li>
<li><p><strong>定义 1.19</strong></p>
<p>​		设函数 $f(x)$ 在 $(x_0 - \delta_0, x_0) ~ (\delta_0 &gt; 0)$ 内有定义，如果对于任意给定的 $\varepsilon &gt; 0$，存在 $\delta &gt; 0 ~ (\delta \leqslant \delta_0)$，当 $x_0 - \delta &lt; x &lt; x_0$ 时，有 $\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon$，则称函数 $f(x)$ 当 $x$ 趋于 $x_0$ 时以 $A$ 为<strong>左极限</strong>，记为 $\lim\limits_{x \to x_0^-} f(x) &#x3D; A$，也记为 $f(x_0 - 0) &#x3D; A$。同理，定义 $f(x)$ 的右极限 $A$，记为 $\lim\limits_{x \to x_0^+} f(x) &#x3D; A$，也记为 $f(x_0 + 0) &#x3D; A$。</p>
<blockquote>
<p><strong>注</strong>	由于 $x$ 趋于 $x_0$ 时的左极限为 $f(x_0 - 0) &#x3D; \lim\limits_{x \to x_0^-} f(x)$，则 $x$ 趋于 $0$ 时的左极限为 $f(0 - 0) &#x3D; \lim\limits_{x \to 0^-} f(x)$；同理 $x$ 趋于 $0$ 时的右极限为 $f(0 + 0) &#x3D; \lim\limits_{x \to 0^+} f(x)$。</p>
</blockquote>
</li>
</ul>
<h4 id="1-3-2-自变量趋于无穷大时函数的极限"><a href="#1-3-2-自变量趋于无穷大时函数的极限" class="headerlink" title="1.3.2 自变量趋于无穷大时函数的极限"></a>1.3.2 自变量趋于无穷大时函数的极限</h4><ul>
<li><p><strong>定义 1.20</strong></p>
<p>​		设存在 $m &gt; 0$，当 $\lvert ~ x ~ \rvert &gt; m$ 时，函数 $f(x)$ 有定义，$A$ 为常数。如果对于任意给定的 $\varepsilon &gt; 0$，总存在 $X &gt; m$，当 $\lvert ~ x ~ \rvert &gt; X$ 时，有 $\lvert ~ f(x) - a ~ \rvert &lt; \varepsilon$，则称函数 $f(x)$ 当 $x$ 趋于无穷大时以 $A$ 为极限，记为 $\lim\limits_{x \to \infty} f(x) &#x3D; A$ 或 $f(x) \to A (x \to \infty)$。</p>
</li>
<li><p><strong>定义 1.21</strong></p>
<p>​		设存在 $m &gt; 0$，当 $x &gt; m$ 时，函数 $f(x)$ 有定义，$A$ 为常数。如果对于任意给定的 $\varepsilon &gt; 0$，总存在 $X &gt; m$，当 $x &gt; X$ 时，有 $\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon$，则称函数 $f(x)$ 当 $x$ 趋于正无穷大时以 $A$ 为极限，记为 $\lim\limits_{x \to +\infty} f(x) &#x3D; A$。</p>
</li>
<li><p><strong>定义 1.22</strong></p>
<p>​		设存在 $m &gt; 0$，当 $x &lt; -m$ 时，函数 $f(x)$ 有定义，$A$ 为常数。如果对于任意给定的 $\varepsilon &gt; 0$，总存在 $X &lt; -m$，当 $x &lt; X$ 时，有 $\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon$，则称函数 $f(x)$ 当 $x$ 趋于负无穷大时以 $A$ 为极限，记为 $\lim\limits_{x \to -\infty} f(x) &#x3D; A$。</p>
</li>
</ul>
<h4 id="1-3-3-函数极限的性质"><a href="#1-3-3-函数极限的性质" class="headerlink" title="1.3.3 函数极限的性质"></a>1.3.3 函数极限的性质</h4><blockquote>
<ol>
<li><p>极限的唯一性：若 $\lim\limits_{x \to x_0} f(x)$ 存在，则极限唯一。</p>
</li>
<li><p>局部有界性：若 $\lim\limits_{x \to x_0} f(x)$ 存在，则存在 $\delta &gt; 0$ 及 $M &gt; 0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) ~ \rvert \leqslant M$。</p>
</li>
<li><p>$\lim\limits_{x \to x_0} f(x)$ 存在的充分必要条件是 $f(x_0 - 0), f(x_0 + 0)$ 存在且相等，且 $\lim\limits_{x \to x_0} f(x) &#x3D; f(x_0 - 0) &#x3D; f(x_0 + 0)$。（用于证明极限是否存在）</p>
</li>
<li><p>极限的保号性：若 $\lim\limits_{x \to x_0} f(x) &#x3D; A &gt; 0$（或 $A &lt; 0$），则存在 $\delta &gt; 0$，当 $0&lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，有 $f(x) &gt; 0$（或 $f(x) &lt; 0$）。（反之不一定）</p>
</li>
<li><p>极限的保序性：若 $\lim\limits_{x \to x_0} f(x)$ 与 $\lim\limits_{x \to x_0} g(x)$ 都存在，且当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; c$ 时，$f(x) \geqslant g(x)$，则 $\lim\limits_{x \to x_0} f(x) \geqslant \lim\limits_{x \to x_0} g(x)$。</p>
</li>
<li><p>夹逼定理：设函数 $f(x), g(x), h(x)$ 满足：（1）存在 $c &gt; 0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; c$ 时，有 $f(x) \leqslant h(x) \leqslant g(x)$；（2）$\lim\limits_{x \to x_0} f(x)$ 与 $\lim\limits_{x \to x_0} g(x)$ 存在且相等。则 $\lim\limits_{x \to x_0} h(x)$ 存在，且 $\lim\limits_{x \to x_0} h(x) &#x3D; \lim\limits_{x \to x_0} f(x) &#x3D; \lim\limits_{x \to x_0} g(x)$。</p>
</li>
</ol>
</blockquote>
<h3 id="1-4-极限的运算法则"><a href="#1-4-极限的运算法则" class="headerlink" title="1.4 极限的运算法则"></a>1.4 极限的运算法则</h3><h4 id="1-4-1-数列极限的运算法则"><a href="#1-4-1-数列极限的运算法则" class="headerlink" title="1.4.1 数列极限的运算法则"></a>1.4.1 数列极限的运算法则</h4><ul>
<li><p><strong>定理 1.8</strong> — 数列极限的运算法则</p>
<p>​		如果 $\lim\limits_{n \to \infty} x_n$ 和 $\lim\limits_{n \to \infty} y_n$ 存在，则（1）$\lim\limits_{n \to \infty} (x_n \pm y_n)$ 存在，且 $\lim\limits_{n \to \infty} (x_n \pm y_n) &#x3D; \lim\limits_{n \to \infty} x_n + \lim\limits_{n \to \infty} y_n$；（2）$\lim\limits_{n \to \infty} (x_n y_n)$ 存在，且 $\lim\limits_{n \to \infty} (x_n y_n) &#x3D; \lim\limits_{n \to \infty} x_n \cdot \lim\limits_{n \to \infty} y_n$；（3）如果 $\lim\limits_{n \to \infty} y_n \neq 0$，则 $\lim\limits_{n \to \infty} \dfrac{x_n}{y_n}$ 存在，且 $\lim\limits_{n \to \infty} \dfrac{x_n}{y_n} &#x3D; \dfrac{\lim\limits_{n \to \infty} x_n}{\lim\limits_{n \to \infty} y_n}$。</p>
<p><strong>证</strong>	（1）设 $\lim\limits_{n \to \infty} x_n &#x3D; A, \lim\limits_{n \to \infty} y_n &#x3D; B$。由极限的定义，$\forall ~ \varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - A ~ \rvert &lt; \varepsilon, \lvert ~ y_n - B ~ \rvert &lt; \varepsilon$。这时，有<br>$$<br>\begin{align}<br>\lvert ~ x_n + y_n - (A + B) ~ \rvert<br>    &amp; &#x3D; \lvert ~ x_n - A + y_n - B ~ \rvert \<br>    &amp; \leqslant \lvert ~ x_n - A ~ \rvert + \lvert ~ y_n - B ~ \rvert &lt; 2 \varepsilon.<br>\end{align}<br>$$<br>于是<br>$$<br>\lim\limits_{n \to \infty} (x_n + y_n) &#x3D; A + B.<br>$$<br>​		（2）设 $\lim\limits_{n \to \infty} x_n &#x3D; A, \lim\limits_{n \to \infty} y_n &#x3D; B$。由极限的定义，$\forall ~ \varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - A ~ \rvert &lt; \varepsilon, \lvert ~ y_n - B ~ \rvert &lt; \varepsilon$。再由收敛数列的有界性，对于任意的 $n$，存在 $M &gt; 0$，使得 $\lvert ~ x_n ~ \rvert &lt; M$。这时，有<br>$$<br>\begin{align}<br>\lvert ~ x_n y_n - A B ~ \rvert<br>    &amp; &#x3D; \lvert ~ x_n y_n - x_n B + x_n B - A B ~ \rvert \<br>    &amp; \leqslant \lvert ~ x_n y_n - x_n B ~ \rvert + \lvert ~ x_n B - A B ~ \rvert &lt; \varepsilon (M + \lvert ~ B ~ \rvert).<br>\end{align}<br>$$<br>于是<br>$$<br>\lim\limits_{n \to \infty} x_n y_n &#x3D; AB.<br>$$<br>​		（3）设 $\lim\limits_{n \to \infty} x_n &#x3D; A, \lim\limits_{n \to \infty} y_n &#x3D; B$。由极限的定义，$\forall ~ \varepsilon &gt; 0$，存在正整数 $N$，当 $n &gt; N$ 时，有 $\lvert ~ x_n - A ~ \rvert &lt; \varepsilon, \lvert ~ y_n - B ~ \rvert &lt; \varepsilon$。再由收敛数列的有界性，对于任意的 $n$，存在 $M &gt; 0$，使得 $\lvert ~ x_n ~ \rvert &lt; M$。对于 $\lvert ~ y_n - B ~ \rvert &lt; \varepsilon$，由绝对值不等式可知<br>$$<br>\lvert ~ B ~ \rvert - \lvert ~ y_n ~ \rvert \leqslant \lvert ~ y_n - B ~ \rvert &lt; \varepsilon,<br>$$<br>则<br>$$<br>\lvert ~ y_n ~ \rvert &gt; \lvert ~ B ~ \rvert - \varepsilon,<br>$$<br>因为 $\lim\limits_{n \to \infty} y_n &#x3D; B \neq 0$，取 $\varepsilon &#x3D; \dfrac{\lvert ~ B ~ \rvert}{2} &gt; 0$，即<br>$$<br>\lvert ~ y_n ~ \rvert &gt; \frac{\lvert ~ B ~ \rvert}{2} &gt; 0, ~ y_n \neq 0<br>$$</p>
<blockquote>
<p><strong>注</strong>	这里的 $y_n \neq 0$ 是在 $n &gt; N, \lim\limits_{n \to \infty} y_n \neq 0$ 条件下的取值，也可以说当 $n \to \infty$ 时，$y_n \neq 0$。同时也要注意，趋于无穷大时的取值和极限值是不同的，将取值比作一条线，那么极限值可以看作它的渐近线（并不是，因为有重合的情况），但是可以将其视为一样的，由此可以推断 $\lim\limits_{n \to \infty} y_n \neq 0 \Rightarrow y_n \neq 0 ~ (n &gt; N)$。</p>
</blockquote>
<p>这时，有<br>$$<br>\begin{align}<br>\lvert ~ \frac{x_n}{y_n} - \frac{A}{B} ~ \rvert<br>    &amp; &#x3D; \lvert ~ \frac{x_n}{y_n} - \frac{x_n}{B} + \frac{x_n}{B} - \frac{A}{B} ~ \rvert \<br>    &amp; \leqslant \lvert ~ \frac{x_n}{y_n} - \frac{x_n}{B} ~ \rvert + \lvert ~ \frac{x_n}{B} - \frac{A}{B} ~ \rvert \<br>    &amp; &#x3D; \lvert ~ x_n ~ \rvert \lvert ~ \frac{1}{y_n} - \frac{1}{B} ~ \rvert + \lvert ~ \frac{1}{B} ~ \rvert \lvert ~ x_n - A ~ \rvert \<br>    &amp; &#x3D; \lvert ~ x_n ~ \rvert \frac{\lvert ~ y_n - B ~ \rvert}{\lvert ~ y_n ~ \rvert \lvert ~ B ~ \rvert} + \frac{1}{\lvert ~ B ~ \rvert} \lvert ~ x_n - A ~ \rvert \<br>    &amp; &lt; M \frac{\varepsilon}{\lvert ~ y_n ~ \rvert \lvert ~ B ~ \rvert} + \frac{\varepsilon}{\lvert ~ B ~ \rvert} \<br>    &amp; &lt; M \frac{2 \varepsilon}{\lvert ~ B ~ \rvert^2} + \frac{\varepsilon}{\lvert ~ B ~ \rvert}.<br>\end{align}<br>$$<br>于是<br>$$<br>\lim\limits_{n \to \infty} \frac{x_n}{y_n} &#x3D; \frac{A}{B}.<br>$$</p>
<blockquote>
<p><strong>注</strong>	因为 ${y_n}$ 有极限的充分条件是 $\varepsilon$ 可取任意值，因此 $y_n$ 的取值应该满足各种 $\varepsilon$ 情况下的取值集合，即对所有取值集合求并集，所以可以确定 $y_n \neq 0$。</p>
</blockquote>
<blockquote>
<ol>
<li>如果 $\lim\limits_{n \to \infty} x_n &#x3D; A \neq 0$，$\lim\limits_{n \to \infty} y_n$ 不存在，则 $\lim\limits_{n \to \infty} (x_n y_n)$ 一定不存在。</li>
<li>如果 $\lim\limits_{n \to \infty} x_n &#x3D; 0$，${y_n}$ 有界，则 $\lim\limits_{n \to \infty} x_n y_n &#x3D; 0$。</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="1-4-2-函数极限的运算法则"><a href="#1-4-2-函数极限的运算法则" class="headerlink" title="1.4.2 函数极限的运算法则"></a>1.4.2 函数极限的运算法则</h4><blockquote>
<p><strong>注</strong>	数列收敛，函数有极限。</p>
</blockquote>
<ul>
<li><p><strong>定理 1.9</strong> — 函数极限的运算法则</p>
<p>​		设 $\lim\limits_{x \to x_0} f(x)$ 和 $\lim\limits_{x \to x_0} g(x)$ 存在，则</p>
<p>（1）$\lim\limits_{x \to x_0} (f(x) \pm g(x))$ 存在，且 $\lim\limits_{x \to x_0} (f(x) \pm g(x)) &#x3D; \lim\limits_{x \to x_0} f(x) \pm \lim\limits_{x \to x_0} g(x)$；</p>
<p>（2）$\lim\limits_{x \to x_0} (f(x) g(x))$ 存在，且 $\lim\limits_{x \to x_0} (f(x) g(x)) &#x3D; \lim\limits_{x \to x_0} f(x) \cdot \lim\limits_{x \to x_0} g(x)$，特别地，$\lim\limits_{x \to x_0} (f(x))^2 &#x3D; (\lim\limits_{x \to x_0} f(x))^2$；</p>
<p>（3）若 $\lim\limits_{x \to x_0} g(x) \neq 0$，则 $\lim\limits_{x \to x_0} \dfrac{f(x)}{g(x)}$ 存在，且 $\lim\limits_{x \to x_0} \dfrac{f(x)}{g(x)} &#x3D; \dfrac{\lim\limits_{x \to x_0} f(x)}{\lim\limits_{x \to x_0} g(x)}$。</p>
<p><strong>证</strong>	（1）设 $\lim\limits_{x \to x_0} f(x) &#x3D; A, \lim\limits_{x \to x_0} g(x) &#x3D; B$。由极限的定义，$\forall ~ \varepsilon &gt; 0$，存在 $0 &lt; \delta \leqslant \delta_0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon, \lvert ~ g(x) - B ~ \rvert &lt; \varepsilon$。这时，有<br>$$<br>\begin{align}<br>\lvert ~ f(x) + g(x) - (A + B) ~ \rvert<br>    &amp; &#x3D; \lvert ~ f(x) - A + g(x) - B ~ \rvert \<br>    &amp; \leqslant \lvert ~ f(x) - A ~ \rvert + \lvert ~ g(x) - B ~ \rvert &lt; 2 \varepsilon.<br>\end{align}<br>$$<br>于是<br>$$<br>\lim\limits_{x \to x_0} (f(x) + g(x)) &#x3D; A + B.<br>$$<br>​		（2）设 $\lim\limits_{x \to x_0} f(x) &#x3D; A, \lim\limits_{x \to x_0} g(x) &#x3D; B$。由极限的定义，$\forall ~ \varepsilon &gt; 0$，存在 $0 &lt; \delta \leqslant \delta_0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon, \lvert ~ g(x) - B ~ \rvert &lt; \varepsilon$。再由函数极限的局部有界性，存在 $\delta &gt; 0$ 且 $M &gt; 0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) ~ \rvert \leqslant M$。这时，有<br>$$<br>\begin{align}<br>    \lvert ~ f(x) g(x) - A B ~ \rvert<br>        &amp; &#x3D; \lvert ~ f(x) g(x) - f(x) B + f(x) B - A B ~ \rvert \<br>        &amp; \leqslant \lvert ~ f(x) g(x) - f(x) B ~ \rvert + \lvert ~ f(x) B - A B ~ \rvert &lt; \varepsilon (M + \lvert ~ B ~ \rvert).<br>\end{align}<br>$$<br>于是<br>$$<br>\lim\limits_{x \to x_0} f(x) g(x) &#x3D; AB.<br>$$</p>
<blockquote>
<p><strong>注</strong>	由于自变量趋于有限值的极限原本就是在某个去心邻域 $\mathring{U} (x, \delta_0)$ 内定义的，因此局部有界性也适用于整个区间。</p>
</blockquote>
<p>（3）设 $\lim\limits_{x \to x_0} f(x) &#x3D; A, \lim\limits_{x \to x_0} g(x) &#x3D; B$。由极限的定义，$\forall ~ \varepsilon &gt; 0$，存在 $0 &lt; \delta \leqslant \delta_0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon, \lvert ~ g(x) - B ~ \rvert &lt; \varepsilon$。再由函数极限的局部有界性，存在 $\delta &gt; 0$ 且 $M &gt; 0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ 时，$\lvert ~ f(x) ~ \rvert \leqslant M$。对于 $\lvert ~ g(x) - B ~ \rvert &lt; \varepsilon$，由绝对值不等式可知<br>$$<br>\lvert ~ B ~ \rvert - \lvert ~ g(x) ~ \rvert \leqslant \lvert ~ g(x) - B ~ \rvert &lt; \varepsilon,<br>$$<br>则<br>$$<br>\lvert ~ g(x) ~ \rvert &gt; \lvert ~ B ~ \rvert - \varepsilon,<br>$$<br>因为 $\lim\limits_{x \to x_0} g(x) &#x3D; B \neq 0$，取 $\varepsilon &#x3D; \dfrac{\lvert ~ B ~ \rvert}{2} &gt; 0$，即<br>$$<br>\lvert ~ g(x) ~ \rvert &gt; \frac{\lvert ~ B ~ \rvert}{2} &gt; 0, ~ g(x) \neq 0<br>$$</p>
<blockquote>
<p><strong>注</strong>	这里的 $g(x) \neq 0$，是在 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta, \lim\limits_{x \to x_0} g(x) \neq 0$ 条件下的取值，也可以说当 $x \to x_0$ 时，$g(x) \neq 0$。同前述观点可以推断 $\lim\limits_{x \to x_0} g(x) \neq 0 \Rightarrow g(x) \neq 0 ~ (0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta)$。</p>
</blockquote>
<p>这时，有<br>$$<br>\begin{align}<br>\lvert ~ \frac{f(x)}{g(x)} - \frac{A}{B} ~ \rvert<br>    &amp; &#x3D; \lvert ~ \frac{f(x)}{g(x)} - \frac{f(x)}{B} + \frac{f(x)}{B} - \frac{A}{B} ~ \rvert \<br>    &amp; \leqslant \lvert ~ \frac{f(x)}{g(x)} - \frac{f(x)}{B} ~ \rvert + \lvert ~ \frac{f(x)}{B} - \frac{A}{B} ~ \rvert \<br>    &amp; &#x3D; \lvert ~ f(x) ~ \rvert \lvert ~ \frac{1}{g(x)} - \frac{1}{B} ~ \rvert + \lvert ~ \frac{1}{B} ~ \rvert \lvert ~ f(x) - A ~ \rvert \<br>    &amp; &#x3D; \lvert ~ f(x) ~ \rvert \frac{\lvert ~ g(x) - B ~ \rvert}{\lvert ~ g(x) ~ \rvert \lvert ~ B ~ \rvert} + \frac{1}{\lvert ~ B ~ \rvert} \lvert ~ f(x) - A ~ \rvert \<br>    &amp; &lt; M \frac{\varepsilon}{\lvert ~ g(x) ~ \rvert \lvert ~ B ~ \rvert} + \frac{\varepsilon}{\lvert ~ B ~ \rvert} \<br>    &amp; &lt; M \frac{2 \varepsilon}{\lvert ~ B ~ \rvert^2} + \frac{\varepsilon}{\lvert ~ B ~ \rvert}.<br>\end{align}<br>$$<br>于是<br>$$<br>\lim\limits_{x \to x_0} \frac{f(x)}{g(x)} &#x3D; \frac{A}{B}.<br>$$</p>
<blockquote>
<p>对于分式函数，若分子分母最高次相等，则极限为其系数之比，若分母次数高于分子，极限为零，否则无极限。5.</p>
</blockquote>
</li>
<li><p><strong>定理 1.10</strong> — 复合函数极限的计算公式</p>
<p>​		如果 $\lim\limits_{x \to x_0} f(x)$ 存在，$\lim\limits_{t \to t_0} g(t) &#x3D; x_0$，且存在 $\delta_0 &gt; 0$，当 $t \in \mathring{U} (t_0, \delta_0)$ 时，$g(t) \neq x_0$，则 $\lim\limits_{t \to t_0} f(g(t))$ 存在，并且有 $\lim\limits_{t \to t_0} f(g(t)) &#x3D; \lim\limits_{x \to x_0} f(x)$。</p>
<p><strong>证</strong>	设 $\lim\limits_{x \to x_0} f(x) &#x3D; A$，由极限的定义知，$\forall ~ \varepsilon &gt; 0$，存在 $\eta &gt; 0$，当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \eta$ 时，<br>$$<br>\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon.<br>$$<br>再由 $\lim\limits_{t \to t_0} g(t) &#x3D; x_0$ 时，对上述的 $\eta$，存在 $\delta_{\eta} &gt; 0$，当 $0 &lt; \lvert ~ t - t_0 ~ \rvert &lt; \delta_{\eta}$ 时，<br>$$<br>\lvert ~ g(t) - x_0 ~ \rvert &lt; \eta.<br>$$<br>由已知，$t \in \mathring{U} (t_0, \delta_0)$ 时，$g(t) \neq x_0$。取 $\delta &#x3D; \min {\delta_0, \delta_{\eta}}$，则当 $0 &lt; \lvert ~ t - t_0 ~ \rvert &lt; \delta$ 时，有<br>$$<br>0 &lt; \lvert ~ g(t) - x_0 ~ \rvert &lt; \eta.<br>$$<br>从而有 $\lvert ~ f(g(t)) - A ~ \rvert &lt; \varepsilon$。</p>
<p>​		即证 $\lim\limits_{t \to t_0} f(g(x)) &#x3D; A$，则 $\lim\limits_{t \to t_0} f(g(t)) &#x3D; \lim\limits_{x \to x_0} f(x)$。</p>
</li>
</ul>
<h3 id="1-5-单调有界原理和两个重要极限"><a href="#1-5-单调有界原理和两个重要极限" class="headerlink" title="1.5 单调有界原理和两个重要极限"></a>1.5 单调有界原理和两个重要极限</h3><h4 id="1-5-1-单调有界原理"><a href="#1-5-1-单调有界原理" class="headerlink" title="1.5.1 单调有界原理"></a>1.5.1 单调有界原理</h4><ul>
<li><p><strong>定理 1.11</strong>	</p>
<p>​		如果 $\lvert ~ x_n ~ \rvert$ 为单调有界数列，则 $\lim\limits_{n \to \infty} x_n$ 存在。</p>
<p><strong>证</strong>	从几何上看，由于单调数列的点 $x_n$ 只能向一个方向移动，所以只有两种可能，或者点 $x_n$ 沿数轴移向无穷远；或者点 $x_n$ 无限趋于某一个定点，即数列 ${x_n}$ 趋于一个定数。但数列 ${x_n}$ 有界，因此，只能出现第二种情形。</p>
<blockquote>
<p>若函数 $f(x)$ 在 $(a, +\infty)$ 内单调增加（减少），且有上界（下界），则 $\lim\limits_{x \to +\infty} f(x)$ 存在。</p>
</blockquote>
</li>
</ul>
<h4 id="1-5-2-两个重要极限"><a href="#1-5-2-两个重要极限" class="headerlink" title="1.5.2 两个重要极限"></a>1.5.2 两个重要极限</h4><blockquote>
<ol>
<li><p>$\lim\limits_{x \to 0} \dfrac{\sin x}{x} &#x3D; 1$</p>
<p>由 $\sin x &lt; x &lt; \tan x$，得 $1 &lt; \dfrac{x}{\sin x} &lt; \dfrac{1}{\cos x}$，取倒数 $\cos x &lt; \dfrac{\sin x}{x} &lt; 1$，由夹逼定理得 $\lim\limits_{x \to 0^+} \dfrac{\sin x}{x} &#x3D; 1$，由函数是偶函数，得 $\lim\limits_{x \to 0^-} \dfrac{\sin x}{x} &#x3D; 1$，因此极限为 $1$。</p>
</li>
<li><p>$\lim\limits_{n \to \infty} \left( 1 + \dfrac{1}{n} \right)^n &#x3D; e$</p>
<p>$\lim\limits_{x \to \infty} \left( 1 + \dfrac{1}{x} \right)^x &#x3D; e, ~ \lim\limits_{x \to 0} (1 + x) ^{\frac{1}{x}} &#x3D; e$</p>
</li>
</ol>
</blockquote>
<h4 id="1-5-3-极限计算的例题"><a href="#1-5-3-极限计算的例题" class="headerlink" title="1.5.3 极限计算的例题"></a>1.5.3 极限计算的例题</h4><h3 id="1-6-无穷小与无穷大"><a href="#1-6-无穷小与无穷大" class="headerlink" title="1.6 无穷小与无穷大"></a>1.6 无穷小与无穷大</h3><h4 id="1-6-1-无穷小"><a href="#1-6-1-无穷小" class="headerlink" title="1.6.1 无穷小"></a>1.6.1 无穷小</h4><ul>
<li><p><strong>定义 1.23</strong></p>
<p>​		在自变量的某个变化过程中，极限为 $0$ 的变量称为<strong>无穷小</strong>。</p>
<blockquote>
<p>$0$ 是唯一一个常数无穷小。</p>
</blockquote>
</li>
<li><p><strong>定理 1.12</strong></p>
<p>​		在自变量的同一变化过程中，函数 $f(x)$ 的极限为 $A$ 的充分必要条件是 $f(x) &#x3D; A + \alpha$，其中 $\alpha$ 是自变量的同一变化过程中的无穷小。</p>
<p><strong>证</strong>	对于自变量趋近于有限值时，充分性：</p>
<p>​		因为 $\lim\limits_{x \to x_0} f(x) &#x3D; A, \lim\limits_{x \to x_0} \alpha &#x3D; 0$，所以 $\lim\limits_{x \to x_0} \alpha &#x3D; \lim\limits_{x \to x_0} f(x) - A &#x3D; \lim\limits_{x \to x_0} (f(x) - A) &#x3D; 0$，所以 $\lim\limits_{x \to x_0} \alpha &#x3D; \lim\limits_{x \to x_0} (f(x) - A)$，即 $f(x) &#x3D; A + \alpha$。</p>
<p>​		必要性：</p>
<p>​		因为 $f(x) &#x3D; A + \alpha, \lim\limits_{x \to x_0} \alpha &#x3D; 0$，所以 $\lim\limits_{x \to x_0} a &#x3D; \lim\limits_{x \to x_0} (f(x) - A) &#x3D; \lim\limits_{x \to x_0} f(x) - A &#x3D; 0$，所以 $\lim\limits_{x \to x_0} f(x) - A &#x3D; 0$，即 $\lim\limits_{x \to x_0} f(x) &#x3D; A$。</p>
</li>
</ul>
<h4 id="1-6-2-无穷大"><a href="#1-6-2-无穷大" class="headerlink" title="1.6.2 无穷大"></a>1.6.2 无穷大</h4><ul>
<li><p><strong>定义 1.24</strong></p>
<p>​		设函数 $f(x)$ 在 $x_0$ 的某个去心邻域 $\mathring{U} (x_0, \delta_0)$ 内有定义（或存在 $X_0 &gt; 0$，当 $\lvert ~ x ~ \rvert &gt; X_0$ 时函数 $f(x)$ 有定义）。如果对于任意给定的 $M &gt; 0$ （无论多么大），总存在 $0 &lt; \delta &lt; \delta_0$ （或存在 $X &gt; X_0 &gt; 0$），当 $0 &lt; \lvert ~ x - x_0 ~ \rvert &lt; \delta$ （或 $\lvert ~ x ~ \rvert &gt; X$）时，恒有 $\lvert ~ f(x) ~ \rvert &gt; M$，则称 $f(x)$ 为 $x \to x_0$ （或 $x \to \infty$）时的无穷大。记为 $f(x) \to \infty$ （$x \to x_0$ 或 $x \to \infty$），有时也记为 $\lim\limits_{x \to x_0} f(x) &#x3D; \infty$ （或 $\lim\limits_{x \to \infty} f(x) &#x3D; \infty$）。</p>
<blockquote>
<p>无穷小与无穷大之间有一种简单的关系：在自变量的同一变化过程中，如果 $f(x)$ 为无穷大，则 $\dfrac{1}{f(x)}$ 为无穷小；反之，如果 $f(x)$ 为无穷小，且 $f(x) \neq 0$，则 $\dfrac{1}{f(x)}$ 为无穷大。</p>
<p>无穷小与无穷大总是与自变量的某个变化过程联系在一起。</p>
</blockquote>
</li>
</ul>
<h4 id="1-6-3-无穷小的运算"><a href="#1-6-3-无穷小的运算" class="headerlink" title="1.6.3 无穷小的运算"></a>1.6.3 无穷小的运算</h4><ul>
<li><p><strong>定理 1.13</strong></p>
<p>​		两个无穷小的和、差仍为无穷小。</p>
<p><strong>证</strong>	设 $\alpha_1, \alpha_2$ 为无穷小，则有 $\lim\limits_{x \to x_0} \alpha_1 &#x3D; 0, \lim\limits_{x \to x_0} \alpha_2 &#x3D; 0$，再由极限运算法则，$\lim\limits_{x \to x_0} (\alpha_1 \pm \alpha_2) &#x3D; \lim\limits_{x \to x_0} \alpha_1 \pm \lim\limits_{x \to x_0} \alpha_2$，得 $\lim\limits_{x \to x_0} (\alpha_1 \pm \alpha_2) &#x3D; 0$，即证。</p>
<blockquote>
<p>无穷多个无穷小的和与乘积不一定是无穷小。</p>
</blockquote>
</li>
<li><p><strong>定理 1.14</strong></p>
<p>​		有界函数与无穷小的乘积仍为无穷小。</p>
<p><strong>证</strong>	设 $f(x)$ 是有界函数，即存在 $M &gt; 0$，使得 $\lvert ~ f(x) ~ \rvert \leqslant M$；设 $g(x)$ 是某一自变量变化过程中的无穷小，则 $\lim\limits_{x \to x_0} g(x) &#x3D; 0$。此时，有<br>$$<br>-M \lvert ~ g(x) ~ \rvert \leqslant \lvert ~ f(x) g(x) ~ \rvert \leqslant M \lvert ~ g(x) ~ \rvert<br>$$<br>对于不等式左右两端，分别有<br>$$<br>\begin{align}<br>\lim_{x \to x_0} (-M \lvert ~ g(x) ~ \rvert) &amp; &#x3D; -M \lim_{x \to x_0} \lvert ~ g(x) ~ \rvert &#x3D; 0 \<br>\lim_{x \to x_0} (M \lvert ~ g(x) ~ \rvert) &amp; &#x3D; M \lim_{x \to x_0} \lvert ~ g(x) ~ \rvert &#x3D; 0 \<br>\end{align}<br>$$<br>有夹逼定理得<br>$$<br>\lim_{x \to x_0} \lvert ~ f(x) g(x) ~ \rvert &#x3D; 0<br>$$<br>从而<br>$$<br>\lim_{x \to x_0} f(x) g(x) &#x3D; 0<br>$$</p>
<blockquote>
<p>因为 $\lim\limits_{x \to x_0} f(x) &#x3D; A$ 时，有 $\lvert ~ f(x) - A ~ \rvert &lt; \varepsilon$，根据绝对值不等式，有 $\lvert ~ \lvert ~ f(x) ~ \rvert - \lvert ~ A ~ \rvert ~ \rvert \leqslant \lvert ~ f(x) - A ~ \rvert \ &lt; \varepsilon$。即说明 $\lim\limits_{x \to x_0} \lvert ~ f(x) ~ \rvert &#x3D; \lvert ~ A ~ \rvert$。</p>
</blockquote>
<ul>
<li><p><strong>推论</strong></p>
<p>​		无限多个无穷小的乘积仍为无穷小。</p>
<p><strong>证</strong>	设 $\alpha_1, \alpha_2, \cdots, \alpha_n$ 为无限多个无穷小，由极限运算法则得 $\lim\limits_{x \to x_0} \alpha_1 \alpha_2 \cdots \alpha_n &#x3D; 0$，即其乘积仍为无穷小。</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-6-4-无穷小的比较"><a href="#1-6-4-无穷小的比较" class="headerlink" title="1.6.4 无穷小的比较"></a>1.6.4 无穷小的比较</h4><blockquote>
<p>设 $\alpha, \beta$ 是自变量在同一变化过程中的两个无穷小。</p>
<ol>
<li>如果 $\lim\limits_{x \to x_0} \dfrac{\beta}{\alpha} &#x3D; 0$，则称 $\beta$ 是比 $\alpha$ 高阶的无穷小，记为 $\beta &#x3D; o(\alpha)$，也说 $\alpha$ 是比 $\beta$ 低阶的无穷小；</li>
<li>如果 $\lim\limits_{x \to x_0} \dfrac{\beta}{\alpha} &#x3D; c$（$c$ 是不为 $0$ 的常数），则称 $\beta$ 是与 $\alpha$ 同阶的无穷小；</li>
<li>如果 $\lim\limits_{x \to x_0} \dfrac{\beta}{\alpha} &#x3D; 1$，则称 $\beta$ 与 $\alpha$ 是等价的无穷小，记作 $\beta \sim \alpha$ 或 $\alpha \sim \beta$；</li>
<li>如果 $\lim\limits_{x \to x_0} \dfrac{\beta}{\alpha^k} &#x3D; c$（$k &gt; 0$，$c$ 是不为 $0$ 的常数），则称 $\beta$ 是关于 $\alpha$ 的 $k$ 阶无穷小。</li>
</ol>
<p>不是所有无穷小都能比较，例如 $\dfrac{1}{x}$ 与 $\dfrac{\sin x}{x}$ 不能进行比较。</p>
</blockquote>
<ul>
<li><p><strong>定理 1.15</strong></p>
<p>​		设 $\alpha, \beta$ 是自变量在同一变化过程中的两个无穷小，则<br>$$<br>\beta \sim \alpha \Leftrightarrow \beta &#x3D; \alpha + o(\alpha).<br>$$<br><strong>证</strong>	充分性，因为 $\beta \sim \alpha$，则 $\lim\limits_{x \to x_0} \dfrac{\beta}{\alpha} &#x3D; 1$，因此 $\lim\limits_{x \to x_0} \dfrac{\beta}{\alpha} - 1 &#x3D; \lim\limits_{x \to x_0} (\dfrac{\beta}{\alpha} - 1) &#x3D; \lim\limits_{x \to x_0} \dfrac{\beta - \alpha}{\alpha} &#x3D; 0$，可知 $\beta - \alpha$ 是 $\alpha$ 的高阶无穷小，得到 $\beta - \alpha &#x3D; o(\alpha)$，即 $\beta &#x3D; \alpha + o(\alpha)$。</p>
<p>​		必要性，逆推。</p>
</li>
<li><p><strong>定理 1.16</strong></p>
<p>​		设 $\alpha, \alpha’, \beta, \beta’$ 都是自变量在同一变化过程中的无穷小，且 $\alpha \sim \alpha’, \beta \sim \beta’$，若 $\dfrac{\beta’}{\alpha’}$ 存在（或为 $\infty$），则 $\lim\limits \dfrac{\beta}{\alpha}$ 存在（或为 $\infty$），且 $\lim\limits \dfrac{\beta}{\alpha} &#x3D; \lim\limits \dfrac{\beta’}{\alpha’}$。</p>
<p><strong>证</strong>	$\lim\limits \dfrac{\beta}{\alpha} &#x3D; \lim\limits (\dfrac{\beta}{\beta’} \cdot \dfrac{\beta’}{\alpha’} \cdot \dfrac{\alpha’}{\alpha}) &#x3D; \lim\limits \dfrac{\beta}{\beta’} \cdot \lim\limits \dfrac{\beta’}{\alpha’} \cdot \lim\limits \dfrac{\alpha’}{\alpha} &#x3D; \lim\limits \dfrac{\beta’}{\alpha’}.$</p>
<blockquote>
<p>无穷小代换。</p>
</blockquote>
</li>
</ul>
<h3 id="1-7-函数的连续性"><a href="#1-7-函数的连续性" class="headerlink" title="1.7 函数的连续性"></a>1.7 函数的连续性</h3><h4 id="1-7-1-函数的连续性"><a href="#1-7-1-函数的连续性" class="headerlink" title="1.7.1 函数的连续性"></a>1.7.1 函数的连续性</h4><ul>
<li><p><strong>定义 1.25</strong></p>
<p>​		设函数 $f(x)$ 在 $x_0$ 的某个邻域内有定义，如果 $\lim\limits_{x \to x_0} f(x) &#x3D; f(x_0)$，则称函数 $f(x)$ 在 $x_0$ 处连续，称 $x_0$ 为 $f(x)$ 的连续点。</p>
<p>​		$\Delta x &#x3D; x - x_0$ 称为自变量 $x$ 在 $x_0$ 处的增量，相应地 $\Delta y &#x3D; f(x_0 + \Delta) - f(x_0)$ 称为 $y &#x3D; f(x)$ 在 $x_0$ 处相对于 $\Delta x$ 的增量。</p>
</li>
<li><p><strong>定义 1.26</strong></p>
<p>​		设函数 $f(x)$ 在区间 $(a, b)$ 内有定义，如果 $f(x)$ 在 $(a, b)$ 内任意点都连续，则称 $f(x)$ 在 $(a, b)$ 内连续，也称 $f(x)$ 为 $(a, b)$ 内的连续函数。</p>
<p>​		如果 $\lim\limits_{x \to x_0^-} f(x) &#x3D; f(x_0)$，则称 $f(x)$ 在 $x_0$ 点左连续。如果 $\lim\limits_{x \to x_0^+} f(x) &#x3D; f(x_0)$，则称 $f(x)$ 在 $x_0$ 点右连续。</p>
</li>
</ul>
<h4 id="1-7-2-连续函数的运算性质"><a href="#1-7-2-连续函数的运算性质" class="headerlink" title="1.7.2 连续函数的运算性质"></a>1.7.2 连续函数的运算性质</h4><ul>
<li><p><strong>定理 1.17</strong></p>
<p>​		设函数 $f(x), g(x)$ 在 $x_0$ 点连续，则 $f(x) \pm g(x), f(x)g(x), \dfrac{f(x)}{g(x)} ~ (g(x_0) \neq 0)$ 也在 $x_0$ 点连续。</p>
<p><strong>证</strong>	因为 $f(x), g(x)$ 在 $x_0$ 点连续，则有 $\lim\limits_{x \to x_0} f(x) &#x3D; f(x_0), \lim\limits_{x \to x_0} g(x) &#x3D; g(x_0)$。以乘积为例，设 $h(x) &#x3D; f(x) g(x)$，由极限运算法则可知，$\lim\limits_{x \to x_0} h(x) &#x3D; \lim\limits_{x \to x_0} f(x) g(x) &#x3D; \lim\limits_{x \to x_0} f(x) \cdot \lim\limits_{x \to x_0} g(x) &#x3D; f(x_0) \cdot g(x_0) &#x3D; h(x_0)$，即 $\lim\limits_{x \to x_0} h(x) &#x3D; h(x_0)$，因此 $h(x)$ 在 $x_0$ 点也连续。</p>
</li>
<li><p><strong>定理 1.18</strong></p>
<p>​		如果函数 $y &#x3D; f(x)$ 在区间 $I_x$ 上单调增加（或减少）且连续，则它的反函数 $x &#x3D; f^{-1}(y)$ 存在并且在相应的区间 $I_y &#x3D; {y ~ \vert ~ y &#x3D; f(x), ~ x \in I_x}$ 上单调增加（或减少）且连续。</p>
<p><strong>证</strong>	设 $I_x &#x3D; [a, b]$，设函数 $f$ 在 $[a, b]$ 上严格增。此时 $f$ 的值域即反函数 $f^{-1}$ 的定义域为 $[f(a), f(b)]$。任取 $y_0 \in (f(a), f(b))$，设 $x_0 &#x3D; f^{-1}(y_0)$，则 $x_0 \in (a, b)$。对任给的 $\varepsilon &gt; 0$，在 $(a, b)$ 上 $x_0$ 的两侧各取异于 $x_0$ 的点 $x_1, x_2$（$x_1 &lt; x_0 &lt; x_2$），使它们与 $x_0$ 的距离小于 $\varepsilon$。</p>
<p>​		设与 $x_1, x_2$ 对应的函数值分别为 $y_1, y_2$，由 $f$ 的严格增性知 $y1 &lt; y_0 &lt; y2$。令<br>$$<br>\delta &#x3D; \min {y_2 - y_0, y_0 - y_1},<br>$$<br>则当 $y \in U(y_0, \delta)$ 时，对应的 $x &#x3D; f^{-1} (y)$ 的值都落在 $x_1$ 与 $x_2$ 之间，故有<br>$$<br>\lvert ~ f^{-1}(y) - f^{-1}(y_0) ~ \rvert &#x3D; \lvert ~ x - x_0 ~ \rvert &lt; \varepsilon,<br>$$<br>即证 $f^{-1}$ 在点 $y_0$ 连续，从而 $f^{-1}$ 在 $(f(a), f(b))$ 内连续。</p>
</li>
<li><p><strong>定理 1.19</strong></p>
<p>​		设函数 $f(x)$ 在 $x &#x3D; x_0$ 处连续，$g(t)$ 在 $t &#x3D; t_0$ 处连续且 $g(t_0) &#x3D; x_0$，则复合函数 $f(g(t))$ 在 $t &#x3D; t_0$ 处连续，即<br>$$<br>\lim\limits_{t \to t_0} f(g(t)) &#x3D; f(g(t_0)) &#x3D; f(\lim\limits_{t \to t_0} g(t)).<br>$$<br><strong>证</strong>	由定理 1.10 知，$\lim\limits_{t \to t_0} f(g(t)) &#x3D; \lim\limits_{x \to x_0} f(x) &#x3D; f(x_0) &#x3D; f(g(t_0))$，即证。</p>
</li>
<li><p><strong>定理 1.20</strong></p>
<p>​		基本初等函数在其定义域内连续，初等函数在其定义区间（定义域内的区间）内连续。</p>
<p><strong>证</strong>	对于常函数 $f(x) &#x3D; c$，$c$ 是常数。任意点的函数极限等于该点的函数值，显然连续。</p>
<p>​		对于幂函数 $f(x) &#x3D; x^{\alpha}$，$\alpha$ 是常数。由连续函数经四则运算也是连续函数可知，幂函数连续。</p>
<p>​		对于指数函数 $f(x) &#x3D; a^x$，$a &gt; 0, a \neq 1$，暂不证明。</p>
<p>​		对于对数函数 $f(x) &#x3D; \log_a x$，$a &gt; 0, a \neq 1$，暂不证明。</p>
<p>​		对于三角函数 $f(x) &#x3D; \sin x, f(x) &#x3D; \cos x, f(x) &#x3D; \tan x$，暂不证明。</p>
<p>​		对于反三角函数 $f(x) &#x3D; \arcsin x, f(x) &#x3D; \arccos x, f(x) &#x3D; \arctan x$，暂不证明。</p>
</li>
</ul>
<h4 id="1-7-3-函数的间断点"><a href="#1-7-3-函数的间断点" class="headerlink" title="1.7.3 函数的间断点"></a>1.7.3 函数的间断点</h4><ul>
<li><p><strong>定义 1.27</strong></p>
<p>​		设函数 $f(x)$ 在点 $x_0$ 处不连续，则称 $f(x)$ 在 $x_0$ 处间断，$x_0$ 称为间断点。</p>
</li>
</ul>
<h3 id="1-8-闭区间上连续函数的性质"><a href="#1-8-闭区间上连续函数的性质" class="headerlink" title="1.8 闭区间上连续函数的性质"></a>1.8 闭区间上连续函数的性质</h3><ul>
<li><p><strong>定理 1.21</strong> — 有界性定理</p>
<p>​		如果函数 $f(x)$ 在闭区间 $[a, b]$ 上连续，则 $f(x)$ 在 $[a, b]$ 上有界，即存在 $M &gt; 0$，对于任意 $x \in [a, b]$，有 $\lvert ~ f(x) ~\rvert \leqslant M$。</p>
<p><strong>证</strong>	反证法，设函数 $f$ 在闭区间 $[a, b]$ 无界，则对于每个正实数 $A$，都存在一个 $x \in [a, b]$，使得 $\lvert ~ f(x) ~ \rvert \geqslant A$，所以对于每个 $n \in N^+$，存在 $x \in [a, b]$，使得 $\lvert ~ f(x) ~ \rvert \geqslant n$，那么可以找到一个序列 ${x_n} \subset [a, b] ~ (n \in N^+)$，使得 $\lvert ~ f(x_n) ~ \rvert \geqslant n$。</p>
<p>​		根据 Bolzano-Weierstrass 定理（凝聚定理&#x2F;列紧性定理&#x2F;致密性定理），这个序列 ${x_n} ~ (n \in N^+)$ 一定含有收敛子列 ${x_{n_k}} ~ (k \in N^+)$。设 $\lim\limits_{k \to \infty} x_{n_k} &#x3D; x_0$，由于 ${x_{n_k}} \subset [a, b]$，则它的极限 $x_0 \in [a, b]$。又 $f$ 是闭区间 $[a, b]$ 上的连续函数，由 Heine 归结原则，有 $\lim\limits_{k \to \infty} f(x_{n_k}) &#x3D; \lim\limits_{x \to x_0} f(x) &#x3D; f(x_0)$，则 $\lvert ~ f(x_0) ~ \rvert &lt; +\infty, \lim\limits_{k \to \infty} \lvert ~ f(x_{n_k}) ~ \rvert &lt; +\infty$，按照假设 $\lvert ~ f(x_{n_k}) ~ \rvert \geqslant n_k \geqslant k$，得 $\lim\limits_{k \to \infty} \lvert ~ f(x_{n_k}) ~ \rvert &#x3D; +\infty$，与假设矛盾，因此 $f$ 是有界函数。</p>
</li>
<li><p><strong>定义 1.28</strong></p>
<p>​		设函数 $f(x)$ 在区间 $I$ 上有定义，如果存在 $x_1 \in I$，对于任意的 $x \in I$，都有<br>$$<br>f(x) \leqslant f(x_1),<br>$$<br>则称 $f(x)$ 在区间 $I$ 上达到最大值，$f(x_1)$ 称为 $f(x)$ 在区间 $I$ 上的最大值。如果存在 $x_2 \in I$，对于任意的 $x \in I$，有 $f(x) \geqslant f(x_2)$，则称 $f(x)$ 在区间 $I$ 上达到最小值，$f(x_2)$ 称为 $f(x)$ 在区间 $I$ 上的最小值。</p>
</li>
<li><p><strong>定理 1.22</strong> — 最值定理</p>
<p>​		如果函数 $f(x)$ 在闭区间 $[a, b]$ 上连续，则存在 $x_1, x_2 \in [a, b]$，对于任意的 $x \in [a, b]$，有 $f(x_2) \leqslant f(x) \leqslant f(x_1)$，即 $f(x)$ 在 $[a, b]$ 上达到最大值和最小值。</p>
<p><strong>证</strong>	值域 $f([a, b])$ 非空，由于 $f$ 在 $[a, b]$ 上有界，由确界原理，$f$ 的值域 $f([a, b])$ 有上确界和下确界，分别记作 $M &#x3D; \sup f([a, b]), m &#x3D; \inf f([a, b])$。</p>
<p>​		只考虑上确界，令 $n \in N^+$，显然 $M - \dfrac{1}{n} &lt; M$。由于 $M$ 是 $f([a, b])$ 的最小上界，所以存在 $y \in f([a, b])$，使得 $M - \dfrac{1}{n} &lt; y &lt; M$，也即存在 $x \in [a, b]$，使得 $M - \dfrac{1}{n} &lt; f(x) \leqslant M$，那么可以找到一个序列 ${x_n} \subset [a, b] ~ (n \in N^+)$，使得 $M - \dfrac{1}{n} &lt; f(x_n) \leqslant M$。</p>
<p>​		根据 Bolzano-Weierstrass 定理，序列 ${x_n} ~ (n \in N^+)$ 一定含有收敛子列 ${x_{n_k}} ~ (k \in N^+)$。设 $\lim\limits_{k \to \infty} x_{n_k} &#x3D; x_{max}$，由于 ${x_{n_k}} \subset [a, b]$，则它的极限 $x_{max} \in [a, b]$，有 $M - \dfrac{1}{n_k} &lt; f(x_{n_k}) \leqslant M$。又 $f$ 是闭区间 $[a, b]$ 上的连续函数，由 Heine 归结原则，有 $\lim\limits_{k \to \infty} f(x_{n_k}) &#x3D; \lim\limits_{x \to x_{max}} f(x) &#x3D; f(x_{max})$。将 $M - \dfrac{1}{n_k} &lt; f(x_{n_k}) \leqslant M$ 取极限，有夹逼定理可得 $f(x_{max}) &#x3D; M$。同理可证明必然存在 $x_{min} \in [a, b]$，使得 $f(x_{min} &#x3D; m)$，得证。</p>
</li>
<li><p><strong>定理 1.23</strong> — 零点定理</p>
<p>​		若函数 $f(x)$ 在闭区间 $[a, b]$ 上连续，且 $f(a) \cdot f(b) &lt; 0$，则至少存在一点 $\xi \in (a, b)$，满足 $f(\xi) &#x3D; 0$。</p>
<p><strong>证</strong>	暂不证明。</p>
</li>
<li><p><strong>定理 1.24</strong> — 介值定理</p>
<p>​		设函数 $f(x)$ 在闭区间 $[a, b]$ 上连续，且 $f(a) \neq f(b)$，则对于介于 $f(a)$ 与 $f(b)$ 之间的任何实数 $c$，至少存在一点 $\xi \in (a, b)$，使得 $f(\xi) &#x3D; c$。</p>
<p><strong>证</strong>	暂不证明。</p>
<ul>
<li><p><strong>推论</strong></p>
<p>​		闭区间上的连续函数一定取得介于函数最小值和最大值之间的任何值。</p>
<p><strong>证</strong>	暂不证明。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
</search>
